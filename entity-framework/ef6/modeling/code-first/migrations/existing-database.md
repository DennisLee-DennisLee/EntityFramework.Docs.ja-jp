---
title: Code First Migrations を既存のデータベースの EF6 で
author: divega
ms.date: 2016-10-23
ms.prod: entity-framework
ms.author: divega
ms.manager: avickers
ms.technology: entity-framework-6
ms.topic: article
ms.assetid: f0cc4f93-67dd-4664-9753-0a9f913814db
caps.latest.revision: 3
ms.openlocfilehash: 77e139a29bb4708b00fc6198a57780ce75197252
ms.sourcegitcommit: bdd06c9a591ba5e6d6a3ec046c80de98f598f3f3
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/10/2018
ms.locfileid: "39122772"
---
# <a name="code-first-migrations-with-an-existing-database"></a>Code First Migrations を既存のデータベースで
> [!NOTE]
> **EF4.3 以降のみ**-機能、Api、Entity Framework 4.1 で導入されたなどのこのページで説明します。 以前のバージョンを使用している場合、一部またはすべての情報は適用されません。

この記事では、いずれかの Entity Framework によって作成されていない既存のデータベースで Code First Migrations の使用について説明します。

> [!NOTE]
> この記事では、基本的なシナリオで Code First Migrations を使用する方法を理解する前提としています。 そうしないかどうかを読み取る必要があります[Code First Migrations](~/ef6/modeling/code-first/migrations/index.md)続行する前にします。

## <a name="screencasts"></a>スクリーン キャスト

この記事を読むよりもスクリーン キャストを見るとではなく、次の 2 つのビデオはこの記事と同じ内容を説明します。

### <a name="video-one-migrations---under-the-hood"></a>ビデオ 1:「移行 - 内部的には」

[このスクリーン キャスト](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood)移行を追跡する方法について説明し、モデルに関する情報を使用して、モデルの変更を検出します。

### <a name="video-two-migrations---existing-databases"></a>ビデオ 2:「移行 - 既存のデータベース」

前のビデオから説明した概念に基づいて[このスクリーン キャスト](http://channel9.msdn.com/blogs/ef/migrations-existing-databases)を有効にして、既存のデータベースでの移行を使用する方法について説明します。

## <a name="step-1-create-a-model"></a>手順 1: モデルを作成します。

既存のデータベースを対象とする Code First モデルを作成する最初の手順になります。 [既存のデータベースを Code First](~/ef6/modeling/code-first/workflows/existing-database.md)トピックがこれを行う方法の詳細なガイダンスを提供します。

>[!NOTE]
> データベース スキーマへの変更が必要となるモデルに変更を加える前に、このトピックの手順の残りの部分を次に重要です。 次の手順に必要なモデルとの同期をデータベース スキーマを使用します。

## <a name="step-2-enable-migrations"></a>手順 2: 移行を有効にします。

次の手順では、移行を有効にします。 実行してこれを行う、 **Enable-migrations**パッケージ マネージャー コンソール コマンド。

このコマンドは、移行と呼ばれる、ソリューション内のフォルダーを作成し、構成と呼ばれる内部の 1 つのクラスを配置します。 構成クラスでは構成の移行、アプリケーションの詳細についてで調べることができます、 [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md)トピック。

## <a name="step-3-add-an-initial-migration"></a>手順 3: 最初の移行を追加します。

移行で作成および適用された後、これらを適用することも、ローカル データベースは他のデータベースに変更します。 たとえば、テスト データベースをローカル データベースがあり、も実稼働データベースに、変更を適用することが最終的にか、他の開発者は、データベースをテストします。 この手順の 2 つのオプションがあるし、1 つ選択する必要がありますが他のすべてのデータベースのスキーマが空か、現在のローカルのデータベースのスキーマと一致するかどうかに依存します。

-   **オプション 1: は、開始点として、既存のスキーマを使用します。** 他のデータベースの移行を将来的に適用されますが、ローカル データベースが現在に同じスキーマがある場合は、この方法を使用する必要があります。 たとえば、ローカル テスト データベースには、v1、実稼働データベースの現在と一致して、v2、実稼働データベースを更新するこれらの移行は後で適用する場合これを使用する場合があります。
-   **オプション 2: は、開始点として空のデータベースを使用します。** 移行を将来的に適用されます他のデータベースが空 (またはまだ存在していない) 場合は、このアプローチを使用します。 たとえば、する場合、テスト データベースを使用して、アプリケーションの開発を開始 migrations を使用することがなくは後でゼロから実稼働データベースを作成するこれを使用する場合があります。

### <a name="option-one-use-existing-schema-as-a-starting-point"></a>オプション 1: 開始点として既存のスキーマを使用します。

Code First Migrations は、モデルの変更を検出するために、最新の移行に格納されたモデルのスナップショットを使用 (この点についての詳細な情報が見つかります[チーム環境での Code First Migrations](~/ef6/modeling/code-first/migrations/teams.md))。 データベースが既に現在のモデルのスキーマであると仮定するため、スナップショットとして現在のモデルが空の (操作なし) 移行を生成します。

1.  実行、 **Add-migration InitialCreate – IgnoreChanges**パッケージ マネージャー コンソール コマンド。 スナップショットとして、現在のモデルに空の移行を作成します。
2.  実行、 **Update-database**パッケージ マネージャー コンソール コマンド。 InitialCreate 移行データベースに適用されます。 行が追加されるだけですので、実際の移行には、すべての変更が含まれていない、 \_\_この移行が既に適用されていることを示す MigrationsHistory テーブル。

### <a name="option-two-use-empty-database-as-a-starting-point"></a>オプション 2: 開始点として空のデータベースを使用します。

このシナリオでは、既にローカル データベースに存在するテーブルを含むゼロからデータベース全体を作成できるへの移行が必要です。 既存のスキーマを作成するロジックを含む InitialCreate 移行を生成しようとしています。 この移行は既に適用されているように見える、既存のデータベース、しましょう。

1.  実行、 **Add-migration InitialCreate**パッケージ マネージャー コンソール コマンド。 これには、既存のスキーマを作成する移行が作成されます。
2.  新しく作成した移行のアップ メソッド内のすべてのコードをコメントします。 これにより、'' 移行を適用するローカルのデータベースすべてなど既存のテーブルを再作成を試みることがなくすることができます。
3.  実行、 **Update-database**パッケージ マネージャー コンソール コマンド。 InitialCreate 移行データベースに適用されます。 実際の移行が含まれていないためすべての変更が (ために一時的にコメント)、行が追加されるだけです、 \_\_この移行が既に適用されていることを示す MigrationsHistory テーブル。
4.  アップ メソッドのコード コメント解除します。 これは、今後作成されるデータベースには、この移行を適用するときに、ローカル データベースに既に存在していたスキーマは移行して作成することを意味します。

## <a name="things-to-be-aware-of"></a>注意すべき点

既存のデータベースに対して移行を使用している場合は注意する必要があるいくつかの点があります。

### <a name="defaultcalculated-names-may-not-match-existing-schema"></a>既定/計算の名前が既存のスキーマが一致しません。

移行は、スキャフォールディング、移行時に明示的に列とテーブルの名前を指定します。 ただし、移行を適用するときに、移行がの既定の名前を計算するその他のデータベース オブジェクトがあります。 これには、インデックスと外部キー制約が含まれます。 既存のスキーマを対象とするときにこれらの計算の名前は、データベースで実際に存在するものが一致しないが。

このことに注意する必要がある場合は、以下には、いくつか例を示します。

**使用した場合 'オプションの 1 つ: 既存のスキーマを使用して、開始点として' 手順 3。**

-   モデル内の将来の変更は、変更またはデータベース オブジェクトが異なるという名前の 1 つを削除する必要がある場合は、正しい名前を指定するへの移行をスキャフォールディングを変更する必要があります。 移行 Api では、これを行うことができるようにする省略可能な名前パラメーターを指定します。
    など、既存のスキーマは IndexFk という名前のインデックスを持つ BlogId の外部キー列と Post のテーブルがある\_BlogId します。 ただし、既定では移行予想 IX 名前を指定するには、このインデックス\_BlogId します。 このインデックスを削除することになるモデルに変更を加えた場合は、スキャフォールディング DropIndex 呼び出しを変更し、IndexFk を指定する必要があります。\_BlogId 名。

**使用した場合 'オプション 2: 開始点として使用して空のデータベース' 手順 3。**

-   ローカル データベースに対して (空のデータベースへの復元) は、初期移行のダウン メソッドを実行しようとしています。 移行はインデックスと不適切な名前を使用して、外部キー制約を削除しようと試みるために失敗します。 これはのみに影響、ローカル データベースから他のデータベースが最初の移行のアップ メソッドを使用して最初から作成されます。
    空の状態には、既存のローカル データベースをダウン グレードする場合は、データベースを削除するか、すべてのテーブルの削除のいずれか、手動で行う最も簡単なは。 この初期グレードは、既定の名前を持つすべてのデータベース オブジェクトを再作成は後、のでこの問題が存在しない自体もう一度です。
-   モデル内の将来の変更は、変更またはデータベース オブジェクトが異なるという名前の 1 つを削除する必要がある場合これに対しては機能しません、既存のローカル データベース – 名前は、既定値と一致しないためです。 ただし、移行によって選択された既定の名前を使用したはために、'一' から作成されたデータベースに対しては機能します。
    ローカルの既存のデータベースにこれらの変更を手動で行うか、またはを他のコンピューターで、移行、データベースをゼロから再作成することを検討する可能性があります。
-   初期移行のアップ メソッドを使用して作成されたデータベース ローカルのデータベースからインデックスの計算される既定の名前からが若干異なるし、外部キー制約が使用されます。 可能性がありますも最終的に余分なインデックスの移行は既定では外部キー列にインデックスを作成する、– このしなかった可能性があります、元のローカル データベース内のケースとして。

### <a name="not-all-database-objects-are-represented-in-the-model"></a>すべてのデータベース オブジェクトは、モデルで表されます

移行は、モデルの一部ではないデータベース オブジェクトには処理されません。 これには、ビュー、ストアド プロシージャ、アクセス許可のモデル、追加のインデックスなどの一部ではないテーブルを含めることができます。

このことに注意する必要がある場合は、以下には、いくつか例を示します。

-   オプションに関係なく選択した '手順 3.' で、モデル内の将来の変更は、変更、またはこれらの変更を移行することはわかりませんこれら追加のオブジェクトを削除する必要がある場合。 たとえばを追加のインデックスを持つ列を削除する場合の移行が登録されていないインデックスを削除します。 スキャフォールディングの移行にこれを手動で追加する必要があります。
-   使用した場合 ' オプション 2: 開始点として使用して空のデータベース '、初期移行のアップ メソッドによってこれらの追加オブジェクトは作成されません。
    場合のこれらの追加オブジェクトを処理するメソッドをおよびを変更することができます。 ビュー: など – 移行 API でネイティブにサポートされていないオブジェクトを使用することができます、 [Sql](https://msdn.microsoft.com/library/system.data.entity.migrations.dbmigration.sql.aspx)メソッドを作成/削除にする SQL そのものを実行します。
