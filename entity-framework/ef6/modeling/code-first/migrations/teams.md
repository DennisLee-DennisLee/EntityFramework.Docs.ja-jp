---
title: チーム環境 - EF6 code First Migrations
author: divega
ms.date: 2016-10-23
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
ms.openlocfilehash: 31f8476c64d36d4d1cf3d18deb59ebc482dcc975
ms.sourcegitcommit: 0d36e8ff0892b7f034b765b15e041f375f88579a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/09/2018
ms.locfileid: "44251233"
---
# <a name="code-first-migrations-in-team-environments"></a>チーム環境での code First Migrations
> [!NOTE]
> この記事では、基本的なシナリオで Code First Migrations を使用する方法を理解する前提としています。 そうしないかどうかを読み取る必要があります[Code First Migrations](~/ef6/modeling/code-first/migrations/index.md)続行する前にします。

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a>コーヒーでも飲んでいて、この記事全体を読み取る必要があります。

チーム環境で問題は、2 人の開発者は、ローカルのコード ベースでの移行を生成したときに、移行のマージに関するほとんどの場合です。 これらを解決する手順は非常に単純ですが、十分に移行のしくみを理解することが必要とします。 くださいしないだけ末尾に進んで: 操作が成功することを確認する全体の記事を読む時間がかかります。

## <a name="some-general-guidelines"></a>一般的なガイドライン

複数の開発者によって生成されたマージの移行を管理する方法を説明する前に、成功をおさめることをいくつかの一般的なガイドラインを示します。

### <a name="each-team-member-should-have-a-local-development-database"></a>各チーム メンバーがローカルの開発用データベースが存在する必要があります。

移行は、  **\_ \_MigrationsHistory**どのような移行をデータベースに適用されているを格納するテーブル。 同じデータベースを対象にしているときにさまざまな移行を生成する複数の開発者がある場合 (したがってを共有し、  **\_ \_MigrationsHistory**テーブル) の移行が非常に混乱を取得ましょう。

もちろん、移行は生成されませんチーム メンバーがあれば、問題を中央の開発データベースを共有することはありません。

### <a name="avoid-automatic-migrations"></a>自動移行を避ける

一番下の行は、自動移行は最初にチーム環境で適切に表示が、実際にだけは動作しません。 まま読み進めて – 理由を知りたい場合いない、次のセクションにスキップできます。

自動移行では、データベース スキーマをコード ファイル (コード ベースの移行) を生成することがなく現在のモデルと一致するように更新を行うことができます。 自動移行はあまり効果がチーム環境でのみそれらを使用して、コード ベースの移行は生成されません。 問題は、プロパティ/列の名前変更、別のテーブルにデータを移動する – 自動移行は限定されており、操作の数を処理しないなどです。最終的にこれらのシナリオを処理するコード ベースの移行を生成する (およびスキャフォールディングされたコードの編集) が混在している間は自動移行によって処理される変更です。 これにより、ほぼ不可能に 2 人の開発者は、移行によってチェックイン時に変更をマージします。

## <a name="screencasts"></a>スクリーン キャスト

この記事を読むよりもスクリーン キャストを見るとではなく、次の 2 つのビデオはこの記事と同じ内容を説明します。

### <a name="video-one-migrations---under-the-hood"></a>ビデオ 1:「移行 - 内部的には」

[このスクリーン キャスト](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood)移行を追跡する方法について説明し、モデルに関する情報を使用して、モデルの変更を検出します。

### <a name="video-two-migrations---team-environments"></a>ビデオ 2:「移行 - チーム環境」

前のビデオから説明した概念に基づいて[このスクリーン キャスト](http://channel9.msdn.com/blogs/ef/migrations-team-environments)チーム環境とその解決方法で発生する問題について説明します。

## <a name="understanding-how-migrations-works"></a>移行のしくみを理解します。

チーム環境で移行を正常を使用するキーは、基本的な移行を追跡する方法を理解することであり、モデルの変更を検出するために、モデルに関する情報を使用します。

### <a name="the-first-migration"></a>最初の移行

ようなものを実行する最初の移行をプロジェクトに追加するときに**Add-migration 最初**パッケージ マネージャー コンソールでします。 このコマンドを実行する手順の概要は次に示します。

![最初の移行](~/ef6/media/firstmigration.png)

現在のモデルは、コード (1) から計算されます。 モデルの違い (2) に必要なデータベース オブジェクトを計算し、– これは、モデルの最初の移行のため異なるだけでは、比較のための空のモデル。 必要な変更は、Visual Studio ソリューション (4) に追加し、必要な移行コード (3) をビルドするコード ジェネレーターに渡されます。

移行には、メイン コード ファイルに格納されている実際の移行コードだけでなく、いくつかの追加のコード ビハインド ファイルも生成されます。 これらのファイルは、移行で使用されるメタデータし、する必要がありますを編集するものではありません。 これらのファイルの 1 つは、移行の生成時に、モデルのスナップショットを含むリソース ファイル (.resx) です。 これを次の手順では、使用する方法を確認します。

この時点でおそらく実行する**Update-database**データベースに変更を適用し、アプリケーションの他の領域を実装する方法をします。

### <a name="subsequent-migrations"></a>次の移行

この例では追加 – モデルに変更して戻って後で、 **Url**プロパティを**ブログ**します。 など、コマンドを発行すると、 **Add-migration AddUrl**適用、対応するデータベースへの移行をスキャフォールディングする変更します。 このコマンドを実行する手順の概要は次に示します。

![2 番目の移行](~/ef6/media/secondmigration.png)

最後の時刻と同じように、現在のモデルは、コード (1) から計算されます。 ただし、この時間がある既存の移行のため、以前のモデルは、最新の移行 (2) から取得されます。 これら 2 つのモデルが必要なデータベースの変更 (3) を見つける差分と、以前と同様、プロセスを完了します。

この同じプロセスは、プロジェクトに追加するをさらに移行するために使用されます。

### <a name="why-bother-with-the-model-snapshot"></a>モデルのスナップショット、なぜわざわざでしょうか。

疑問 – モデルのスナップショットと EF がなぜ面倒理由だけでなく、データベースで参照してください。 そうである場合で読み取ります。 関心がない場合は、このセクションをスキップできます。

多くの EF の周囲のモデルのスナップショットを保持する理由があります。

-   データベース ユーザー、EF モデルからのずれをできます。 データベースで直接変更できます。 または変更を行う、移行でスキャフォールディングされたコードを変更することができます。 実際には、この例をいくつか次に示します。
    -   テーブルの 1 つ以上の列に、挿入と更新を追加したいが、EF モデルにこれらの列を含める必要はありません。 場合に、移行をスキャフォールディングするたびに、これらの列を削除しようと継続的に、データベースの移行について説明しました。 モデルのスナップショットを使用して、EF は、モデルの正当な変更を検出しかします。
    -   いくつかのログ記録の更新に使用するストアド プロシージャの本体を変更するには。 場合、移行がデータベースからこのストアド プロシージャで参照される継続的と EF が必要とする定義にリセットします。 モデルのスナップショットを使用すると、EF が EF モデルのプロシージャの形状を変更するときに、ストアド プロシージャを変更するためのコードしか用意されます。
    -   余分なインデックスを追加、データベースに余分なテーブルを含む、テーブルなどの上に存在するデータベース ビューへの EF のマッピングにこれらの同じ原則が適用されます。
-   EF モデルには、データベースの図形だけが含まれています。 モデル全体については、モデル列およびテーブルへの割り当て方法でクラスとプロパティを見てへの移行できます。 この情報は、スキャフォールディング コードによりインテリジェントで移行できます。 たとえば、プロパティは、移行にマップされる列の名前を変更する場合を検出できますで名前の変更はデータベース スキーマのみがある場合に行うことができないものと同じプロパティ – ことを確認。 

## <a name="what-causes-issues-in-team-environments"></a>チーム環境での問題を原因します。

ワークフローは、アプリケーションで作業する開発者で 1 つが、うまく、前のセクションで説明します。 モデルに変更を加えるだけを担当している場合も、チーム環境でも動作します。 このシナリオでモデルを変更、移行を生成でき、ソース管理に送信できます。 他の開発者が、変更を同期して実行できる**Update-database**スキーマ変更を適用します。

問題は、複数の開発者が EF モデルを変更して同時に、ソース管理に送信する必要があるときに発生を開始します。 EF のないは、最後に同期するため、他の開発者がソース管理に送信するための移行で、ローカルの移行をマージするファースト クラスの方法です。

## <a name="an-example-of-a-merge-conflict"></a>マージ競合の例

最初、このようなマージの競合の具体的な例を見てみましょう。 前出の例とにいく予定です。 みましょうポイントから元の開発者に、前のセクションからの変更がチェックインされたと仮定します。 2 人の開発者、変更するコード ベースとして追跡します。

EF モデルと、多数の変更からの移行を追跡します。 開始ポイントでは、両方の開発者が次の図に示すように、ソース管理リポジトリに同期します。

![開始点](~/ef6/media/startingpoint.png)

開発者\#1 と開発者\#2 がいくつかの変更はローカルのコード内での EF モデルに基本。 開発者\#1 を追加、**評価**プロパティを**ブログ**– し、生成、 **AddRating**移行データベースに変更を適用します。 開発者\#2 の追加、**リーダー**プロパティを**ブログ**– し、対応する生成**AddReaders**移行します。 両方の開発者が実行**Update-database**、し、そのローカルのデータベースに変更を適用し、アプリケーションの開発を続けます。

> [!NOTE]
> 移行というプレフィックスが付いた、タイムスタンプを持つため、グラフィックを表している開発者からの移行を AddReaders \#AddRating 移行の開発者から来る 2 \#1。 かどうか開発者\#1 または\#2 で生成される移行の先頭には、チーム、またはマージして、次のセクションで紹介するためのプロセスでの作業の問題に違いはありません。

![ローカルの変更](~/ef6/media/localchanges.png)

どうやら開発者にとっては\#1 最初の変更を送信することが行われるとします。 誰もがチェックされているためはリポジトリを同期するため、すべてのマージを実行せず、変更内容だけ送信できます。

![送信](~/ef6/media/submit.png)

では、開発者の時間\#2 を送信します。 これらはほど幸運の持ち主はありません。 他のユーザーが同期するために変更が送信とためには、変更とマージをプルする必要があります。 ソース管理システムは非常に単純であるために、コード レベルで変更を自動的にマージする可能性がありますできます。 開発者の状態\#2 のローカル リポジトリの次の図に示すように、同期後にします。 

![プル](~/ef6/media/pull.png)

このステージング開発者\#2 を実行できます**データベースを更新**これは、新しい検出**AddRating**移行 (開発者が適用されていない\#2 のデータベース) を適用します。 今すぐ、**評価**に列が追加、**ブログ**テーブルおよびデータベースは、モデルとの同期。

ただし、いくつかの問題があります。

1.  **Update-database**適用されます、 **AddRating**警告が発生も移行:*保留中の変更があるため、現在のモデルに合わせてデータベースを更新できませんでしたと。自動移行が無効になっているとしています.*
    問題は、最後の移行にモデルのスナップショットが格納されている (**AddReader**) がありません、**評価**プロパティ**ブログ**(ため、モデルの一部ではないことと、移行が生成されました)。 まず、コードは、最後の移行でモデルが、現在のモデルと一致しないし、警告が発生することを検出します。
2.  アプリケーションを実行していることを示す InvalidOperationException でなります"*データベースが作成されたために、'BloggingContext' コンテキストのバックアップ モデルが変更されました。Code First Migrations を使用して... データベースを更新することを検討してください"*
    ここでも、問題は、最後の移行に格納されているモデルのスナップショットは、現在のモデルと一致しません。
3.  最後に、実行が予想されるが**Add-migration**ようになりましたが、空の移行 (ために生成、データベースに適用する変更はありません)。 移行は、最後の移行からのものに、現在のモデルを比較するため、(これは、不足している、**評価**プロパティ) 別スキャフォールディングが実際に**AddColumn** で追加する呼び出し**評価**列。 もちろん、この移行は失敗時に**Update-database**ため、**評価**列は既に存在します。

## <a name="resolving-the-merge-conflict"></a>マージ競合を解決します。

良い知らせはことはできません-手動でマージを処理するほど難しくの移行のしくみを理解していればします。 このセクションに進んでスキップした場合に. 申し訳ありませんをクリックして戻り、最初に、この記事の残りの部分を読む必要があります。

2 つのオプションをスナップショットとして適切な現在のモデルを持つ空の移行を生成する最も簡単なことです。 2 番目のオプションは正しいが、最後の移行のスナップショットを更新するモデルのスナップショット。 2 番目のオプションが少し困難し、すべてのシナリオでは使用できませんが、追加の移行を追加することが関与しないためにもクリーナー。

### <a name="option-1-add-a-blank-merge-migration"></a>オプション 1: 空白の「マージ」移行を追加します。

最新の移行ことを確認するためだけの空の移行を生成するこのオプションで、適切なモデルのスナップショットが格納されています。

このオプションができますに関係なく、最後の移行を生成しました。 例では開発者に従っているした\#2 は、merge の対処し、最後の移行を生成する発生しました。 場合、同じ手順を使用できますが、開発者\#1 は、最後の移行を生成します。 手順は、だけまで見てきた 2 つの単純さの維持するために複数の移行が含まれている場合にも適用されます。

次のプロセスは、この方法は、ソース管理から同期する必要がある変更があることを理解する時点から使用できます。

1.  ローカルのコード ベースでの保留中のモデル変更が、移行に書き込まれたことを確認します。 この手順により、空の移行を生成する際に、正当な変更を見逃すことはありません。
2.  ソース管理と同期します。
3.  実行**Update-database**で他の開発者がチェックされて、新しい移行を適用します。
    **
    *注: * * * Update-database コマンドからの警告を取得しないかどうか、他の開発者からの新しい移行がなかったし、それ以上のマージを実行する必要はありません。*
4.  実行**Add-migration&lt;選択\_、\_名前&gt;– IgnoreChanges** (たとえば、 **Add-migration マージ – IgnoreChanges**)。 (現在のモデルのスナップショットを含む) すべてのメタデータと、移行を生成しますこれが、最後の移行のスナップショットには、現在のモデルを比較するときに検出されたすべての変更は無視されます (つまり空白を取得する**を**と。**ダウン**メソッド)。
5.  での開発を続けるか、(もちろん、単体テスト) の後にソース管理に送信します。

開発者の状態を次に示します\#2 のローカル コード ベース後、このアプローチを使用します。

![移行を差し込み印刷します。](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a>オプション 2: 最後の移行でモデルのスナップショットを更新します。

このオプションは、オプション 1 とよく似ていますが、余分な空白の移行-が削除現実問題のソリューションに追加のコード ファイルを希望します。

**この方法は、最新の移行は、ローカルのコード ベースでのみが存在しがまだ送信されていないソース管理に (たとえば、最後の移行は、マージを実行するユーザーによって生成された) 場合にのみ適して**します。 – 自分の開発用データベースにも、他の開発者を既に適用していますが移行のメタデータの編集に悪いことに実稼働データベースに適用されることが予期しない副作用です。 処理中に、ローカル データベースで最後の移行をロールバックし、更新されたメタデータを使用してを再適用になります。

だけに必要な最後の移行中には、ローカルのコードがそれを続行する移行の順序に制限はありませんがベースであります。 複数のさまざまな開発者からの複数の移行可能性があると同じ手順を適用 – だけまで見てきた 2 つの単純さの維持するためにします。

次のプロセスは、この方法は、ソース管理から同期する必要がある変更があることを理解する時点から使用できます。

1.  ローカルのコード ベースでの保留中のモデル変更が、移行に書き込まれたことを確認します。 この手順により、空の移行を生成する際に、正当な変更を見逃すことはありません。
2.  ソース管理と同期します。
3.  実行**Update-database**で他の開発者がチェックされて、新しい移行を適用します。
    **
    *注: * * * Update-database コマンドからの警告を取得しないかどうか、他の開発者からの新しい移行がなかったし、それ以上のマージを実行する必要はありません。*
4.  実行**Update-database – TargetMigration &lt;2 番目\_最後\_移行&gt;** (従ってきた私たちの例で **– データベースを更新TargetMigration AddRating**)。 この最後移行 – 効果的に 'されていない適用'、データベースから最後の移行のロール、データベースが 2 番目の状態に戻します。
    **
    *注: * * * で、メタデータが格納されていることもあるため、移行のメタデータを編集するのには安全のためにこの手順が必要な\_ \_MigrationsHistoryTable データベースの。これは、場合、最後の移行は、ローカルのコード ベースでのみこのオプションを使用する必要がありますのみであるためにです。他のデータベースがある最後の移行が適用される場合もしなければならないというにロールバックして、メタデータを更新する最後の移行を再適用します。* 
5.  実行**Add-migration&lt;完全\_名前\_など\_タイムスタンプ\_の\_最後\_移行**&gt; (例では従ってきた私たちのようになります**Add-migration 201311062215252\_AddReaders**)。
    **
    *注: * * * の移行は、新しいものをスキャフォールディングするのではなく、既存の移行を編集するを認識できるように、タイムスタンプを含める必要があります。*
    これにより、現在のモデルと一致する最後の移行のメタデータが更新されます。 コマンドが完了したらが、正確にすると、次の警告が表示されます。 "*移行 ' 201311062215252 デザイナー コードだけ\_AddReaders' が再スキャフォールディングします。全体の移行のスキャフォールディングをやり直すを使用して、-force パラメーターです"。*
6.  実行**Update-database**更新されたメタデータを最新の移行を再適用します。
7.  での開発を続けるか、(もちろん、単体テスト) の後にソース管理に送信します。

開発者の状態を次に示します\#2 のローカル コード ベース後、このアプローチを使用します。

![更新されたメタデータ](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a>まとめ

チーム環境で Code First Migrations を使用する場合は、いくつかの課題にもあります。 ただし、移行のしくみとマージの競合を解決するための簡単な方法をいくつかの基本的な知識を使用すると、これらの課題を克服するために簡単できます。

基本的な問題は、正しくないメタデータが最新の移行に格納されているです。 これにより、不適切なコードでは、次の移行をスキャフォールディングして、現在のモデルとデータベース スキーマが一致しないことと正しく検出するために、最初のコード。 このような状況は、適切なモデルでは、空の移行を生成するか、最新の移行でメタデータを更新することによって解決できます。
