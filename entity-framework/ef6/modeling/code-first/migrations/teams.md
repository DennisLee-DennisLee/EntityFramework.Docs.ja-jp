---
title: チーム環境 - EF6 code First Migrations
author: divega
ms.date: 10/23/2016
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
ms.openlocfilehash: 53460b6cdd454099ccf93b4e2133e4ea21278a64
ms.sourcegitcommit: fa863883f1193d2118c2f9cee90808baa5e3e73e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/04/2018
ms.locfileid: "52857469"
---
# <a name="code-first-migrations-in-team-environments"></a><span data-ttu-id="33cdf-102">チーム環境での code First Migrations</span><span class="sxs-lookup"><span data-stu-id="33cdf-102">Code First Migrations in Team Environments</span></span>
> [!NOTE]
> <span data-ttu-id="33cdf-103">この記事では、基本的なシナリオで Code First Migrations を使用する方法を理解する前提としています。</span><span class="sxs-lookup"><span data-stu-id="33cdf-103">This article assumes you know how to use Code First Migrations in basic scenarios.</span></span> <span data-ttu-id="33cdf-104">そうしないかどうかを読み取る必要があります[Code First Migrations](~/ef6/modeling/code-first/migrations/index.md)続行する前にします。</span><span class="sxs-lookup"><span data-stu-id="33cdf-104">If you don’t, then you’ll need to read [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) before continuing.</span></span>

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a><span data-ttu-id="33cdf-105">コーヒーでも飲んでいて、この記事全体を読み取る必要があります。</span><span class="sxs-lookup"><span data-stu-id="33cdf-105">Grab a coffee, you need to read this whole article</span></span>

<span data-ttu-id="33cdf-106">チーム環境で問題は、2 人の開発者は、ローカルのコード ベースでの移行を生成したときに、移行のマージに関するほとんどの場合です。</span><span class="sxs-lookup"><span data-stu-id="33cdf-106">The issues in team environments are mostly around merging migrations when two developers have generated migrations in their local code base.</span></span> <span data-ttu-id="33cdf-107">これらを解決する手順は非常に単純ですが、十分に移行のしくみを理解することが必要とします。</span><span class="sxs-lookup"><span data-stu-id="33cdf-107">While the steps to solve these are pretty simple, they require you to have a solid understanding of how migrations works.</span></span> <span data-ttu-id="33cdf-108">くださいしないだけ末尾に進んで: 操作が成功することを確認する全体の記事を読む時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="33cdf-108">Please don’t just skip ahead to the end – take the time to read the whole article to ensure you are successful.</span></span>

## <a name="some-general-guidelines"></a><span data-ttu-id="33cdf-109">一般的なガイドライン</span><span class="sxs-lookup"><span data-stu-id="33cdf-109">Some general guidelines</span></span>

<span data-ttu-id="33cdf-110">複数の開発者によって生成されたマージの移行を管理する方法を説明する前に、成功をおさめることをいくつかの一般的なガイドラインを示します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-110">Before we dig into how to manage merging migrations generated by multiple developers, here are some general guidelines to set you up for success.</span></span>

### <a name="each-team-member-should-have-a-local-development-database"></a><span data-ttu-id="33cdf-111">各チーム メンバーがローカルの開発用データベースが存在する必要があります。</span><span class="sxs-lookup"><span data-stu-id="33cdf-111">Each team member should have a local development database</span></span>

<span data-ttu-id="33cdf-112">移行は、  **\_ \_MigrationsHistory**どのような移行をデータベースに適用されているを格納するテーブル。</span><span class="sxs-lookup"><span data-stu-id="33cdf-112">Migrations uses the **\_\_MigrationsHistory** table to store what migrations have been applied to the database.</span></span> <span data-ttu-id="33cdf-113">同じデータベースを対象にしているときにさまざまな移行を生成する複数の開発者がある場合 (したがってを共有し、  **\_ \_MigrationsHistory**テーブル) の移行が非常に混乱を取得ましょう。</span><span class="sxs-lookup"><span data-stu-id="33cdf-113">If you have multiple developers generating different migrations while trying to target the same database (and thus share a **\_\_MigrationsHistory** table) migrations is going to get very confused.</span></span>

<span data-ttu-id="33cdf-114">もちろん、移行は生成されませんチーム メンバーがあれば、問題を中央の開発データベースを共有することはありません。</span><span class="sxs-lookup"><span data-stu-id="33cdf-114">Of course, if you have team members that aren’t generating migrations, there is no problem having them share a central development database.</span></span>

### <a name="avoid-automatic-migrations"></a><span data-ttu-id="33cdf-115">自動移行を避ける</span><span class="sxs-lookup"><span data-stu-id="33cdf-115">Avoid automatic migrations</span></span>

<span data-ttu-id="33cdf-116">一番下の行は、自動移行は最初にチーム環境で適切に表示が、実際にだけは動作しません。</span><span class="sxs-lookup"><span data-stu-id="33cdf-116">The bottom line is that automatic migrations initially look good in team environments, but in reality they just don’t work.</span></span> <span data-ttu-id="33cdf-117">まま読み進めて – 理由を知りたい場合いない、次のセクションにスキップできます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-117">If you want to know why, keep reading – if not, then you can skip to the next section.</span></span>

<span data-ttu-id="33cdf-118">自動移行では、データベース スキーマをコード ファイル (コード ベースの移行) を生成することがなく現在のモデルと一致するように更新を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-118">Automatic migrations allows you to have your database schema updated to match the current model without the need to generate code files (code-based migrations).</span></span> <span data-ttu-id="33cdf-119">自動移行はあまり効果がチーム環境でのみそれらを使用して、コード ベースの移行は生成されません。</span><span class="sxs-lookup"><span data-stu-id="33cdf-119">Automatic migrations would work very well in a team environment if you only ever used them and never generated any code-based migrations.</span></span> <span data-ttu-id="33cdf-120">問題は、プロパティ/列の名前変更、別のテーブルにデータを移動する – 自動移行は限定されており、操作の数を処理しないなどです。最終的にこれらのシナリオを処理するコード ベースの移行を生成する (およびスキャフォールディングされたコードの編集) が混在している間は自動移行によって処理される変更です。</span><span class="sxs-lookup"><span data-stu-id="33cdf-120">The problem is that automatic migrations are limited and don’t handle a number of operations – property/column renames, moving data to another table, etc. To handle these scenarios you end up generating code-based migrations (and editing the scaffolded code) that are mixed in between changes that are handled by automatic migrations.</span></span> <span data-ttu-id="33cdf-121">これにより、ほぼ不可能に 2 人の開発者は、移行によってチェックイン時に変更をマージします。</span><span class="sxs-lookup"><span data-stu-id="33cdf-121">This makes it near on impossible to merge changes when two developers check in migrations.</span></span>

## <a name="screencasts"></a><span data-ttu-id="33cdf-122">スクリーン キャスト</span><span class="sxs-lookup"><span data-stu-id="33cdf-122">Screencasts</span></span>

<span data-ttu-id="33cdf-123">この記事を読むよりもスクリーン キャストを見るとではなく、次の 2 つのビデオはこの記事と同じ内容を説明します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-123">If you'd rather watch a screencast than read this article, the following two videos cover the same content as this article.</span></span>

### <a name="video-one-migrations---under-the-hood"></a><span data-ttu-id="33cdf-124">ビデオ 1:「移行 - 内部的には」</span><span class="sxs-lookup"><span data-stu-id="33cdf-124">Video One: "Migrations - Under the Hood"</span></span>

<span data-ttu-id="33cdf-125">[このスクリーン キャスト](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood)移行を追跡する方法について説明し、モデルに関する情報を使用して、モデルの変更を検出します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-125">[This screencast](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood) covers how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="video-two-migrations---team-environments"></a><span data-ttu-id="33cdf-126">ビデオ 2:「移行 - チーム環境」</span><span class="sxs-lookup"><span data-stu-id="33cdf-126">Video Two: "Migrations - Team Environments"</span></span>

<span data-ttu-id="33cdf-127">前のビデオから説明した概念に基づいて[このスクリーン キャスト](http://channel9.msdn.com/blogs/ef/migrations-team-environments)チーム環境とその解決方法で発生する問題について説明します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-127">Building on the concepts from the previous video, [this screencast](http://channel9.msdn.com/blogs/ef/migrations-team-environments) covers the issues that arise in a team environment and how to solve them.</span></span>

## <a name="understanding-how-migrations-works"></a><span data-ttu-id="33cdf-128">移行のしくみを理解します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-128">Understanding how migrations works</span></span>

<span data-ttu-id="33cdf-129">チーム環境で移行を正常を使用するキーは、基本的な移行を追跡する方法を理解することであり、モデルの変更を検出するために、モデルに関する情報を使用します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-129">The key to successfully using migrations in a team environment is a basic understanding how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="the-first-migration"></a><span data-ttu-id="33cdf-130">最初の移行</span><span class="sxs-lookup"><span data-stu-id="33cdf-130">The first migration</span></span>

<span data-ttu-id="33cdf-131">ようなものを実行する最初の移行をプロジェクトに追加するときに**Add-migration 最初**パッケージ マネージャー コンソールでします。</span><span class="sxs-lookup"><span data-stu-id="33cdf-131">When you add the first migration to your project, you run something like **Add-Migration First** in Package Manager Console.</span></span> <span data-ttu-id="33cdf-132">このコマンドを実行する手順の概要は次に示します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-132">The high level steps that this command performs are pictured below.</span></span>

![最初の移行](~/ef6/media/firstmigration.png)

<span data-ttu-id="33cdf-134">現在のモデルは、コード (1) から計算されます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-134">The current model is calculated from your code (1).</span></span> <span data-ttu-id="33cdf-135">モデルの違い (2) に必要なデータベース オブジェクトを計算し、– これは、モデルの最初の移行のため異なるだけでは、比較のための空のモデル。</span><span class="sxs-lookup"><span data-stu-id="33cdf-135">The required database objects are then calculated by the model differ (2) – since this is the first migration the model differ just uses an empty model for the comparison.</span></span> <span data-ttu-id="33cdf-136">必要な変更は、Visual Studio ソリューション (4) に追加し、必要な移行コード (3) をビルドするコード ジェネレーターに渡されます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-136">The required changes are passed to the code generator to build the required migration code (3) which is then added to your Visual Studio solution (4).</span></span>

<span data-ttu-id="33cdf-137">移行には、メイン コード ファイルに格納されている実際の移行コードだけでなく、いくつかの追加のコード ビハインド ファイルも生成されます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-137">In addition to the actual migration code that is stored in the main code file, migrations also generates some additional code-behind files.</span></span> <span data-ttu-id="33cdf-138">これらのファイルは、移行で使用されるメタデータし、する必要がありますを編集するものではありません。</span><span class="sxs-lookup"><span data-stu-id="33cdf-138">These files are metadata that is used by migrations and are not something you should edit.</span></span> <span data-ttu-id="33cdf-139">これらのファイルの 1 つは、移行の生成時に、モデルのスナップショットを含むリソース ファイル (.resx) です。</span><span class="sxs-lookup"><span data-stu-id="33cdf-139">One of these files is a resource file (.resx) that contains a snapshot of the model at the time the migration was generated.</span></span> <span data-ttu-id="33cdf-140">これを次の手順では、使用する方法を確認します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-140">You’ll see how this is used in the next step.</span></span>

<span data-ttu-id="33cdf-141">この時点でおそらく実行する**Update-database**データベースに変更を適用し、アプリケーションの他の領域を実装する方法をします。</span><span class="sxs-lookup"><span data-stu-id="33cdf-141">At this point you would probably run **Update-Database** to apply your changes to the database, and then go about implementing other areas of your application.</span></span>

### <a name="subsequent-migrations"></a><span data-ttu-id="33cdf-142">次の移行</span><span class="sxs-lookup"><span data-stu-id="33cdf-142">Subsequent migrations</span></span>

<span data-ttu-id="33cdf-143">この例では追加 – モデルに変更して戻って後で、 **Url**プロパティを**ブログ**します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-143">Later you come back and make some changes to your model – in our example we’ll add a **Url** property to **Blog**.</span></span> <span data-ttu-id="33cdf-144">など、コマンドを発行すると、 **Add-migration AddUrl**適用、対応するデータベースへの移行をスキャフォールディングする変更します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-144">You would then issue a command such as **Add-Migration AddUrl** to scaffold a migration to apply the corresponding database changes.</span></span> <span data-ttu-id="33cdf-145">このコマンドを実行する手順の概要は次に示します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-145">The high level steps that this command performs are pictured below.</span></span>

![2 番目の移行](~/ef6/media/secondmigration.png)

<span data-ttu-id="33cdf-147">最後の時刻と同じように、現在のモデルは、コード (1) から計算されます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-147">Just like last time, the current model is calculated from code (1).</span></span> <span data-ttu-id="33cdf-148">ただし、この時間がある既存の移行のため、以前のモデルは、最新の移行 (2) から取得されます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-148">However, this time there are existing migrations so the previous model is retrieved from the latest migration (2).</span></span> <span data-ttu-id="33cdf-149">これら 2 つのモデルが必要なデータベースの変更 (3) を見つける差分と、以前と同様、プロセスを完了します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-149">These two models are diffed to find the required database changes (3) and then the process completes as before.</span></span>

<span data-ttu-id="33cdf-150">この同じプロセスは、プロジェクトに追加するをさらに移行するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-150">This same process is used for any further migrations that you add to the project.</span></span>

### <a name="why-bother-with-the-model-snapshot"></a><span data-ttu-id="33cdf-151">モデルのスナップショット、なぜわざわざでしょうか。</span><span class="sxs-lookup"><span data-stu-id="33cdf-151">Why bother with the model snapshot?</span></span>

<span data-ttu-id="33cdf-152">疑問 – モデルのスナップショットと EF がなぜ面倒理由だけでなく、データベースで参照してください。</span><span class="sxs-lookup"><span data-stu-id="33cdf-152">You may be wondering why EF bothers with the model snapshot – why not just look at the database.</span></span> <span data-ttu-id="33cdf-153">そうである場合で読み取ります。</span><span class="sxs-lookup"><span data-stu-id="33cdf-153">If so, read on.</span></span> <span data-ttu-id="33cdf-154">関心がない場合は、このセクションをスキップできます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-154">If you’re not interested then you can skip this section.</span></span>

<span data-ttu-id="33cdf-155">多くの EF の周囲のモデルのスナップショットを保持する理由があります。</span><span class="sxs-lookup"><span data-stu-id="33cdf-155">There are a number of reasons EF keeps the model snapshot around:</span></span>

-   <span data-ttu-id="33cdf-156">データベース ユーザー、EF モデルからのずれをできます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-156">It allows your database to drift from the EF model.</span></span> <span data-ttu-id="33cdf-157">データベースで直接変更できます。 または変更を行う、移行でスキャフォールディングされたコードを変更することができます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-157">These changes can be made directly in the database, or you can change the scaffolded code in your migrations to make the changes.</span></span> <span data-ttu-id="33cdf-158">実際には、この例をいくつか次に示します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-158">Here are a couple of examples of this in practice:</span></span>
    -   <span data-ttu-id="33cdf-159">テーブルの 1 つ以上の列に、挿入と更新を追加したいが、EF モデルにこれらの列を含める必要はありません。</span><span class="sxs-lookup"><span data-stu-id="33cdf-159">You want to add an Inserted and Updated to column to one or more of your tables but you don’t want to include these columns in the EF model.</span></span> <span data-ttu-id="33cdf-160">場合に、移行をスキャフォールディングするたびに、これらの列を削除しようと継続的に、データベースの移行について説明しました。</span><span class="sxs-lookup"><span data-stu-id="33cdf-160">If migrations looked at the database it would continually try to drop these columns every time you scaffolded a migration.</span></span> <span data-ttu-id="33cdf-161">モデルのスナップショットを使用して、EF は、モデルの正当な変更を検出しかします。</span><span class="sxs-lookup"><span data-stu-id="33cdf-161">Using the model snapshot, EF will only ever detect legitimate changes to the model.</span></span>
    -   <span data-ttu-id="33cdf-162">いくつかのログ記録の更新に使用するストアド プロシージャの本体を変更するには。</span><span class="sxs-lookup"><span data-stu-id="33cdf-162">You want to change the body of a stored procedure used for updates to include some logging.</span></span> <span data-ttu-id="33cdf-163">場合、移行がデータベースからこのストアド プロシージャで参照される継続的と EF が必要とする定義にリセットします。</span><span class="sxs-lookup"><span data-stu-id="33cdf-163">If migrations looked at this stored procedure from the database it would continually try and reset it back to the definition that EF expects.</span></span> <span data-ttu-id="33cdf-164">モデルのスナップショットを使用すると、EF が EF モデルのプロシージャの形状を変更するときに、ストアド プロシージャを変更するためのコードしか用意されます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-164">By using the model snapshot, EF will only ever scaffold code to alter the stored procedure when you change the shape of the procedure in the EF model.</span></span>
    -   <span data-ttu-id="33cdf-165">余分なインデックスを追加、データベースに余分なテーブルを含む、テーブルなどの上に存在するデータベース ビューへの EF のマッピングにこれらの同じ原則が適用されます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-165">These same principles apply to adding extra indexes, including extra tables in your database, mapping EF to a database view that sits over a table, etc.</span></span>
-   <span data-ttu-id="33cdf-166">EF モデルには、データベースの図形だけが含まれています。</span><span class="sxs-lookup"><span data-stu-id="33cdf-166">The EF model contains more than just the shape of the database.</span></span> <span data-ttu-id="33cdf-167">モデル全体については、モデル列およびテーブルへの割り当て方法でクラスとプロパティを見てへの移行できます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-167">Having the entire model allows migrations to look at information about the properties and classes in your model and how they map to the columns and tables.</span></span> <span data-ttu-id="33cdf-168">この情報は、スキャフォールディング コードによりインテリジェントで移行できます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-168">This information allows migrations to be more intelligent in the code that it scaffolds.</span></span> <span data-ttu-id="33cdf-169">たとえば、プロパティは、移行にマップされる列の名前を変更する場合を検出できますで名前の変更はデータベース スキーマのみがある場合に行うことができないものと同じプロパティ – ことを確認。</span><span class="sxs-lookup"><span data-stu-id="33cdf-169">For example, if you change the name of the column that a property maps to migrations can detect the rename by seeing that it’s the same property – something that can’t be done if you only have the database schema.</span></span> 

## <a name="what-causes-issues-in-team-environments"></a><span data-ttu-id="33cdf-170">チーム環境での問題を原因します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-170">What causes issues in team environments</span></span>

<span data-ttu-id="33cdf-171">ワークフローは、アプリケーションで作業する開発者で 1 つが、うまく、前のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-171">The workflow covered in the previous section works great when you are a single developer working on an application.</span></span> <span data-ttu-id="33cdf-172">モデルに変更を加えるだけを担当している場合も、チーム環境でも動作します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-172">It also works well in a team environment if you are the only person making changes to the model.</span></span> <span data-ttu-id="33cdf-173">このシナリオでモデルを変更、移行を生成でき、ソース管理に送信できます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-173">In this scenario you can make model changes, generate migrations and submit them to your source control.</span></span> <span data-ttu-id="33cdf-174">他の開発者が、変更を同期して実行できる**Update-database**スキーマ変更を適用します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-174">Other developers can sync your changes and run **Update-Database** to have the schema changes applied.</span></span>

<span data-ttu-id="33cdf-175">問題は、複数の開発者が EF モデルを変更して同時に、ソース管理に送信する必要があるときに発生を開始します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-175">Issues start to arise when you have multiple developers making changes to the EF model and submitting to source control at the same time.</span></span> <span data-ttu-id="33cdf-176">EF のないは、最後に同期するため、他の開発者がソース管理に送信するための移行で、ローカルの移行をマージするファースト クラスの方法です。</span><span class="sxs-lookup"><span data-stu-id="33cdf-176">What EF lacks is a first class way to merge your local migrations with migrations that another developer has submitted to source control since you last synced.</span></span>

## <a name="an-example-of-a-merge-conflict"></a><span data-ttu-id="33cdf-177">マージ競合の例</span><span class="sxs-lookup"><span data-stu-id="33cdf-177">An example of a merge conflict</span></span>

<span data-ttu-id="33cdf-178">最初、このようなマージの競合の具体的な例を見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="33cdf-178">First let’s look at a concrete example of such a merge conflict.</span></span> <span data-ttu-id="33cdf-179">前出の例とにいく予定です。</span><span class="sxs-lookup"><span data-stu-id="33cdf-179">We’ll continue on with the example we looked at earlier.</span></span> <span data-ttu-id="33cdf-180">みましょうポイントから元の開発者に、前のセクションからの変更がチェックインされたと仮定します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-180">As a starting point let’s assume the changes from the previous section were checked in by the original developer.</span></span> <span data-ttu-id="33cdf-181">2 人の開発者、変更するコード ベースとして追跡します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-181">We’ll track two developers as they make changes to code base.</span></span>

<span data-ttu-id="33cdf-182">EF モデルと、多数の変更からの移行を追跡します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-182">We’ll track the EF model and the migrations thru a number of changes.</span></span> <span data-ttu-id="33cdf-183">開始ポイントでは、両方の開発者が次の図に示すように、ソース管理リポジトリに同期します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-183">For a starting point, both developers have synced to the source control repository, as depicted in the following graphic.</span></span>

![開始点](~/ef6/media/startingpoint.png)

<span data-ttu-id="33cdf-185">開発者\#1 と開発者\#2 がいくつかの変更はローカルのコード内での EF モデルに基本。</span><span class="sxs-lookup"><span data-stu-id="33cdf-185">Developer \#1 and developer \#2 now makes some changes to the EF model in their local code base.</span></span> <span data-ttu-id="33cdf-186">開発者\#1 を追加、**評価**プロパティを**ブログ**– し、生成、 **AddRating**移行データベースに変更を適用します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-186">Developer \#1 adds a **Rating** property to **Blog** – and generates an **AddRating** migration to apply the changes to the database.</span></span> <span data-ttu-id="33cdf-187">開発者\#2 の追加、**リーダー**プロパティを**ブログ**– し、対応する生成**AddReaders**移行します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-187">Developer \#2 adds a **Readers** property to **Blog** – and generates the corresponding **AddReaders** migration.</span></span> <span data-ttu-id="33cdf-188">両方の開発者が実行**Update-database**、し、そのローカルのデータベースに変更を適用し、アプリケーションの開発を続けます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-188">Both developers run **Update-Database**, to apply the changes to their local databases, and then continue developing the application.</span></span>

> [!NOTE]
> <span data-ttu-id="33cdf-189">移行というプレフィックスが付いた、タイムスタンプを持つため、グラフィックを表している開発者からの移行を AddReaders \#AddRating 移行の開発者から来る 2 \#1。</span><span class="sxs-lookup"><span data-stu-id="33cdf-189">Migrations are prefixed with a timestamp, so our graphic represents that the AddReaders migration from Developer \#2 comes after the AddRating migration from Developer \#1.</span></span> <span data-ttu-id="33cdf-190">かどうか開発者\#1 または\#2 で生成される移行の先頭には、チーム、またはマージして、次のセクションで紹介するためのプロセスでの作業の問題に違いはありません。</span><span class="sxs-lookup"><span data-stu-id="33cdf-190">Whether developer \#1 or \#2 generated the migration first makes no difference to the issues of working in a team, or the process for merging them that we’ll look at in the next section.</span></span>

![ローカルの変更](~/ef6/media/localchanges.png)

<span data-ttu-id="33cdf-192">どうやら開発者にとっては\#1 最初の変更を送信することが行われるとします。</span><span class="sxs-lookup"><span data-stu-id="33cdf-192">It’s a lucky day for Developer \#1 as they happen to submit their changes first.</span></span> <span data-ttu-id="33cdf-193">誰もがチェックされているためはリポジトリを同期するため、すべてのマージを実行せず、変更内容だけ送信できます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-193">Because no one else has checked in since they synced their repository, they can just submit their changes without performing any merging.</span></span>

![送信](~/ef6/media/submit.png)

<span data-ttu-id="33cdf-195">では、開発者の時間\#2 を送信します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-195">Now it’s time for Developer \#2 to submit.</span></span> <span data-ttu-id="33cdf-196">これらはほど幸運の持ち主はありません。</span><span class="sxs-lookup"><span data-stu-id="33cdf-196">They aren’t so lucky.</span></span> <span data-ttu-id="33cdf-197">他のユーザーが同期するために変更が送信とためには、変更とマージをプルする必要があります。</span><span class="sxs-lookup"><span data-stu-id="33cdf-197">Because someone else has submitted changes since they synced, they will need to pull down the changes and merge.</span></span> <span data-ttu-id="33cdf-198">ソース管理システムは非常に単純であるために、コード レベルで変更を自動的にマージする可能性がありますできます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-198">The source control system will likely be able to automatically merge the changes at the code level since they are very simple.</span></span> <span data-ttu-id="33cdf-199">開発者の状態\#2 のローカル リポジトリの次の図に示すように、同期後にします。</span><span class="sxs-lookup"><span data-stu-id="33cdf-199">The state of Developer \#2’s local repository after syncing is depicted in the following graphic.</span></span> 

![プル](~/ef6/media/pull.png)

<span data-ttu-id="33cdf-201">このステージング開発者\#2 を実行できます**データベースを更新**これは、新しい検出**AddRating**移行 (開発者が適用されていない\#2 のデータベース) を適用します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-201">At this stage Developer \#2 can run **Update-Database** which will detect the new **AddRating** migration (which hasn’t been applied to Developer \#2’s database) and apply it.</span></span> <span data-ttu-id="33cdf-202">今すぐ、**評価**に列が追加、**ブログ**テーブルおよびデータベースは、モデルとの同期。</span><span class="sxs-lookup"><span data-stu-id="33cdf-202">Now the **Rating** column is added to the **Blogs** table and the database is in sync with the model.</span></span>

<span data-ttu-id="33cdf-203">ただし、いくつかの問題があります。</span><span class="sxs-lookup"><span data-stu-id="33cdf-203">There are a couple of problems though:</span></span>

1.  <span data-ttu-id="33cdf-204">**Update-database**適用されます、 **AddRating**警告が発生も移行:*保留中の変更があるため、現在のモデルに合わせてデータベースを更新できませんでしたと。自動移行が無効になっているとしています.*</span><span class="sxs-lookup"><span data-stu-id="33cdf-204">Although **Update-Database** will apply the **AddRating** migration it will also raise a warning: *Unable to update database to match the current model because there are pending changes and automatic migration is disabled…*</span></span>
    <span data-ttu-id="33cdf-205">問題は、最後の移行にモデルのスナップショットが格納されている (**AddReader**) がありません、**評価**プロパティ**ブログ**(ため、モデルの一部ではないことと、移行が生成されました)。</span><span class="sxs-lookup"><span data-stu-id="33cdf-205">The problem is that the model snapshot stored in the last migration (**AddReader**) is missing the **Rating** property on **Blog** (since it wasn’t part of the model when the migration was generated).</span></span> <span data-ttu-id="33cdf-206">まず、コードは、最後の移行でモデルが、現在のモデルと一致しないし、警告が発生することを検出します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-206">Code First detects that the model in the last migration doesn’t match the current model and raises the warning.</span></span>
2.  <span data-ttu-id="33cdf-207">アプリケーションを実行していることを示す InvalidOperationException でなります"*データベースが作成されたために、'BloggingContext' コンテキストのバックアップ モデルが変更されました。Code First Migrations を使用して... データベースを更新することを検討してください"*</span><span class="sxs-lookup"><span data-stu-id="33cdf-207">Running the application would result in an InvalidOperationException stating that “*The model backing the 'BloggingContext' context has changed since the database was created. Consider using Code First Migrations to update the database…”*</span></span>
    <span data-ttu-id="33cdf-208">ここでも、問題は、最後の移行に格納されているモデルのスナップショットは、現在のモデルと一致しません。</span><span class="sxs-lookup"><span data-stu-id="33cdf-208">Again, the problem is the model snapshot stored in the last migration doesn’t match the current model.</span></span>
3.  <span data-ttu-id="33cdf-209">最後に、実行が予想されるが**Add-migration**ようになりましたが、空の移行 (ために生成、データベースに適用する変更はありません)。</span><span class="sxs-lookup"><span data-stu-id="33cdf-209">Finally, we would expect running **Add-Migration** now would generate an empty migration (since there are no changes to apply to the database).</span></span> <span data-ttu-id="33cdf-210">移行は、最後の移行からのものに、現在のモデルを比較するため、(これは、不足している、**評価**プロパティ) 別スキャフォールディングが実際に**AddColumn** で追加する呼び出し**評価**列。</span><span class="sxs-lookup"><span data-stu-id="33cdf-210">But because migrations compares the current model to the one from the last migration (which is missing the **Rating** property) it will actually scaffold another **AddColumn** call to add in the **Rating** column.</span></span> <span data-ttu-id="33cdf-211">もちろん、この移行は失敗時に**Update-database**ため、**評価**列は既に存在します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-211">Of course, this migration would fail during **Update-Database** because the **Rating** column already exists.</span></span>

## <a name="resolving-the-merge-conflict"></a><span data-ttu-id="33cdf-212">マージ競合を解決します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-212">Resolving the merge conflict</span></span>

<span data-ttu-id="33cdf-213">良い知らせはことはできません-手動でマージを処理するほど難しくの移行のしくみを理解していればします。</span><span class="sxs-lookup"><span data-stu-id="33cdf-213">The good news is that it’s not too hard to deal with the merge manually – provided you have an understanding of how migrations works.</span></span> <span data-ttu-id="33cdf-214">このセクションに進んでスキップした場合に.</span><span class="sxs-lookup"><span data-stu-id="33cdf-214">So if you’ve skipped ahead to this section…</span></span> <span data-ttu-id="33cdf-215">申し訳ありませんをクリックして戻り、最初に、この記事の残りの部分を読む必要があります。</span><span class="sxs-lookup"><span data-stu-id="33cdf-215">sorry, you need to go back and read the rest of the article first!</span></span>

<span data-ttu-id="33cdf-216">2 つのオプションをスナップショットとして適切な現在のモデルを持つ空の移行を生成する最も簡単なことです。</span><span class="sxs-lookup"><span data-stu-id="33cdf-216">There are two options, the easiest is to generate a blank migration that has the correct current model as a snapshot.</span></span> <span data-ttu-id="33cdf-217">2 番目のオプションは正しいが、最後の移行のスナップショットを更新するモデルのスナップショット。</span><span class="sxs-lookup"><span data-stu-id="33cdf-217">The second option is to update the snapshot in the last migration to have the correct model snapshot.</span></span> <span data-ttu-id="33cdf-218">2 番目のオプションが少し困難し、すべてのシナリオでは使用できませんが、追加の移行を追加することが関与しないためにもクリーナー。</span><span class="sxs-lookup"><span data-stu-id="33cdf-218">The second option is a little harder and can’t be used in every scenario, but it’s also cleaner because it doesn’t involve adding an extra migration.</span></span>

### <a name="option-1-add-a-blank-merge-migration"></a><span data-ttu-id="33cdf-219">オプション 1: 空白の「マージ」移行を追加します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-219">Option 1: Add a blank ‘merge’ migration</span></span>

<span data-ttu-id="33cdf-220">最新の移行ことを確認するためだけの空の移行を生成するこのオプションで、適切なモデルのスナップショットが格納されています。</span><span class="sxs-lookup"><span data-stu-id="33cdf-220">In this option we generate a blank migration solely for the purpose of making sure the latest migration has the correct model snapshot stored in it.</span></span>

<span data-ttu-id="33cdf-221">このオプションができますに関係なく、最後の移行を生成しました。</span><span class="sxs-lookup"><span data-stu-id="33cdf-221">This option can be used regardless of who generated the last migration.</span></span> <span data-ttu-id="33cdf-222">例では開発者に従っているした\#2 は、merge の対処し、最後の移行を生成する発生しました。</span><span class="sxs-lookup"><span data-stu-id="33cdf-222">In the example we’ve been following Developer \#2 is taking care of the merge and they happened to generate the last migration.</span></span> <span data-ttu-id="33cdf-223">場合、同じ手順を使用できますが、開発者\#1 は、最後の移行を生成します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-223">But these same steps can be used if Developer \#1 generated the last migration.</span></span> <span data-ttu-id="33cdf-224">手順は、だけまで見てきた 2 つの単純さの維持するために複数の移行が含まれている場合にも適用されます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-224">The steps also apply if there are multiple migrations involved – we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="33cdf-225">次のプロセスは、この方法は、ソース管理から同期する必要がある変更があることを理解する時点から使用できます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-225">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="33cdf-226">ローカルのコード ベースでの保留中のモデル変更が、移行に書き込まれたことを確認します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-226">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="33cdf-227">この手順により、空の移行を生成する際に、正当な変更を見逃すことはありません。</span><span class="sxs-lookup"><span data-stu-id="33cdf-227">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="33cdf-228">ソース管理と同期します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-228">Sync with source control.</span></span>
3.  <span data-ttu-id="33cdf-229">実行**Update-database**で他の開発者がチェックされて、新しい移行を適用します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-229">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="33cdf-230">**_注:_**  *Update-database コマンドからの警告を取得しないかどうか、他の開発者からの新しい移行がなかったし、それ以上のマージを実行する必要はありません。*</span><span class="sxs-lookup"><span data-stu-id="33cdf-230">**_Note:_** *if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="33cdf-231">実行**Add-migration&lt;選択\_、\_名前&gt;– IgnoreChanges** (たとえば、 **Add-migration マージ – IgnoreChanges**)。</span><span class="sxs-lookup"><span data-stu-id="33cdf-231">Run **Add-Migration &lt;pick\_a\_name&gt; –IgnoreChanges** (for example, **Add-Migration Merge –IgnoreChanges**).</span></span> <span data-ttu-id="33cdf-232">(現在のモデルのスナップショットを含む) すべてのメタデータと、移行を生成しますこれが、最後の移行のスナップショットには、現在のモデルを比較するときに検出されたすべての変更は無視されます (つまり空白を取得する**を**と。**ダウン**メソッド)。</span><span class="sxs-lookup"><span data-stu-id="33cdf-232">This generates a migration with all the metadata (including a snapshot of the current model) but will ignore any changes it detects when comparing the current model to the snapshot in the last migrations (meaning you get a blank **Up** and **Down** method).</span></span>
5.  <span data-ttu-id="33cdf-233">での開発を続けるか、(もちろん、単体テスト) の後にソース管理に送信します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-233">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="33cdf-234">開発者の状態を次に示します\#2 のローカル コード ベース後、このアプローチを使用します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-234">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![移行を差し込み印刷します。](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a><span data-ttu-id="33cdf-236">オプション 2: 最後の移行でモデルのスナップショットを更新します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-236">Option 2: Update the model snapshot in the last migration</span></span>

<span data-ttu-id="33cdf-237">このオプションは、オプション 1 とよく似ていますが、余分な空白の移行-が削除現実問題のソリューションに追加のコード ファイルを希望します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-237">This option is very similar to option 1 but removes the extra blank migration – because let’s face it, who wants extra code files in their solution.</span></span>

<span data-ttu-id="33cdf-238">**この方法は、最新の移行は、ローカルのコード ベースでのみが存在しがまだ送信されていないソース管理に (たとえば、最後の移行は、マージを実行するユーザーによって生成された) 場合にのみ適して**します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-238">**This approach is only feasible if the latest migration exists only in your local code base and has not yet been submitted to source control (for example, if the last migration was generated by the user doing the merge)**.</span></span> <span data-ttu-id="33cdf-239">– 自分の開発用データベースにも、他の開発者を既に適用していますが移行のメタデータの編集に悪いことに実稼働データベースに適用されることが予期しない副作用です。</span><span class="sxs-lookup"><span data-stu-id="33cdf-239">Editing the metadata of migrations that other developers may have already applied to their development database – or even worse applied to a production database – can result in unexpected side effects.</span></span> <span data-ttu-id="33cdf-240">処理中に、ローカル データベースで最後の移行をロールバックし、更新されたメタデータを使用してを再適用になります。</span><span class="sxs-lookup"><span data-stu-id="33cdf-240">During the process we’re going to roll back the last migration in our local database and re-apply it with updated metadata.</span></span>

<span data-ttu-id="33cdf-241">だけに必要な最後の移行中には、ローカルのコードがそれを続行する移行の順序に制限はありませんがベースであります。</span><span class="sxs-lookup"><span data-stu-id="33cdf-241">While the last migration needs to just be in the local code base there are no restrictions to the number or order of migrations that proceed it.</span></span> <span data-ttu-id="33cdf-242">複数のさまざまな開発者からの複数の移行可能性があると同じ手順を適用 – だけまで見てきた 2 つの単純さの維持するためにします。</span><span class="sxs-lookup"><span data-stu-id="33cdf-242">There can be multiple migrations from multiple different developers and the same steps apply– we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="33cdf-243">次のプロセスは、この方法は、ソース管理から同期する必要がある変更があることを理解する時点から使用できます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-243">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="33cdf-244">ローカルのコード ベースでの保留中のモデル変更が、移行に書き込まれたことを確認します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-244">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="33cdf-245">この手順により、空の移行を生成する際に、正当な変更を見逃すことはありません。</span><span class="sxs-lookup"><span data-stu-id="33cdf-245">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="33cdf-246">ソース管理と同期します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-246">Sync with the source control.</span></span>
3.  <span data-ttu-id="33cdf-247">実行**Update-database**で他の開発者がチェックされて、新しい移行を適用します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-247">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="33cdf-248">**_注:_**  *Update-database コマンドからの警告を取得しないかどうか、他の開発者からの新しい移行がなかったし、それ以上のマージを実行する必要はありません。*</span><span class="sxs-lookup"><span data-stu-id="33cdf-248">**_Note:_** *if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="33cdf-249">実行**Update-database – TargetMigration &lt;2 番目\_最後\_移行&gt;** (従ってきた私たちの例で **– データベースを更新TargetMigration AddRating**)。</span><span class="sxs-lookup"><span data-stu-id="33cdf-249">Run **Update-Database –TargetMigration &lt;second\_last\_migration&gt;** (in the example we’ve been following this would be **Update-Database –TargetMigration AddRating**).</span></span> <span data-ttu-id="33cdf-250">この最後移行 – 効果的に 'されていない適用'、データベースから最後の移行のロール、データベースが 2 番目の状態に戻します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-250">This roles the database back to the state of the second last migration – effectively ‘un-applying’ the last migration from the database.</span></span>
    <span data-ttu-id="33cdf-251">**_注:_**  *でメタデータが格納されていることもあるため、移行のメタデータを編集するのには安全のためにこの手順が必要な\_ \_MigrationsHistoryTable のデータベース。これは、場合、最後の移行は、ローカルのコード ベースでのみこのオプションを使用する必要がありますのみであるためにです。他のデータベースがある最後の移行が適用される場合もしなければならないというにロールバックして、メタデータを更新する最後の移行を再適用します。*</span><span class="sxs-lookup"><span data-stu-id="33cdf-251">**_Note:_** *This step is required to make it safe to edit the metadata of the migration since the metadata is also stored in the \_\_MigrationsHistoryTable of the database. This is why you should only use this option if the last migration is only in your local code base. If other databases had the last migration applied you would also have to roll them back and re-apply the last migration to update the metadata.*</span></span> 
5.  <span data-ttu-id="33cdf-252">実行**Add-migration&lt;完全\_名前\_など\_タイムスタンプ\_の\_最後\_移行**&gt; (例では従ってきた私たちのようになります**Add-migration 201311062215252\_AddReaders**)。</span><span class="sxs-lookup"><span data-stu-id="33cdf-252">Run **Add-Migration &lt;full\_name\_including\_timestamp\_of\_last\_migration**&gt; (in the example we’ve been following this would be something like **Add-Migration 201311062215252\_AddReaders**).</span></span>
    <span data-ttu-id="33cdf-253">**_注:_**  *移行は、新しいものをスキャフォールディングするのではなく、既存の移行を編集するを認識できるように、タイムスタンプを含める必要があります。*</span><span class="sxs-lookup"><span data-stu-id="33cdf-253">**_Note:_** *You need to include the timestamp so that migrations knows you want to edit the existing migration rather than scaffolding a new one.*</span></span>
    <span data-ttu-id="33cdf-254">これにより、現在のモデルと一致する最後の移行のメタデータが更新されます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-254">This will update the metadata for the last migration to match the current model.</span></span> <span data-ttu-id="33cdf-255">コマンドが完了したらが、正確にすると、次の警告が表示されます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-255">You’ll get the following warning when the command completes, but that’s exactly what you want.</span></span> <span data-ttu-id="33cdf-256">"*移行 ' 201311062215252 デザイナー コードだけ\_AddReaders' が再スキャフォールディングします。全体の移行のスキャフォールディングをやり直すを使用して、-force パラメーターです"。*</span><span class="sxs-lookup"><span data-stu-id="33cdf-256">“*Only the Designer Code for migration '201311062215252\_AddReaders' was re-scaffolded. To re-scaffold the entire migration, use the -Force parameter.”*</span></span>
6.  <span data-ttu-id="33cdf-257">実行**Update-database**更新されたメタデータを最新の移行を再適用します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-257">Run **Update-Database** to re-apply the latest migration with the updated metadata.</span></span>
7.  <span data-ttu-id="33cdf-258">での開発を続けるか、(もちろん、単体テスト) の後にソース管理に送信します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-258">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="33cdf-259">開発者の状態を次に示します\#2 のローカル コード ベース後、このアプローチを使用します。</span><span class="sxs-lookup"><span data-stu-id="33cdf-259">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![更新されたメタデータ](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a><span data-ttu-id="33cdf-261">まとめ</span><span class="sxs-lookup"><span data-stu-id="33cdf-261">Summary</span></span>

<span data-ttu-id="33cdf-262">チーム環境で Code First Migrations を使用する場合は、いくつかの課題にもあります。</span><span class="sxs-lookup"><span data-stu-id="33cdf-262">There are some challenges when using Code First Migrations in a team environment.</span></span> <span data-ttu-id="33cdf-263">ただし、移行のしくみとマージの競合を解決するための簡単な方法をいくつかの基本的な知識を使用すると、これらの課題を克服するために簡単できます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-263">However, a basic understanding of how migrations works and some simple approaches for resolving merge conflicts make it easy to overcome these challenges.</span></span>

<span data-ttu-id="33cdf-264">基本的な問題は、正しくないメタデータが最新の移行に格納されているです。</span><span class="sxs-lookup"><span data-stu-id="33cdf-264">The fundamental issue is incorrect metadata stored in the latest migration.</span></span> <span data-ttu-id="33cdf-265">これにより、不適切なコードでは、次の移行をスキャフォールディングして、現在のモデルとデータベース スキーマが一致しないことと正しく検出するために、最初のコード。</span><span class="sxs-lookup"><span data-stu-id="33cdf-265">This causes Code First to incorrectly detect that the current model and database schema don’t match and to scaffold incorrect code in the next migration.</span></span> <span data-ttu-id="33cdf-266">このような状況は、適切なモデルでは、空の移行を生成するか、最新の移行でメタデータを更新することによって解決できます。</span><span class="sxs-lookup"><span data-stu-id="33cdf-266">This situation can be overcome by generating a blank migration with the correct model, or updating the metadata in the latest migration.</span></span>
