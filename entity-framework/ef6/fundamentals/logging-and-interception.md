---
title: ログ記録と EF6 のデータベース操作の受信
author: divega
ms.date: 2016-10-23
ms.prod: entity-framework
ms.author: divega
ms.manager: avickers
ms.technology: entity-framework-6
ms.topic: article
ms.assetid: b5ee7eb1-88cc-456e-b53c-c67e24c3f8ca
caps.latest.revision: 3
ms.openlocfilehash: 1d0e953309f3c81a2941d6850e169aaa31ae8de0
ms.sourcegitcommit: bdd06c9a591ba5e6d6a3ec046c80de98f598f3f3
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/10/2018
ms.locfileid: "39122799"
---
# <a name="logging-and-intercepting-database-operations"></a><span data-ttu-id="a1002-102">ログに記録して、データベース操作の受信</span><span class="sxs-lookup"><span data-stu-id="a1002-102">Logging and intercepting database operations</span></span>
> [!NOTE]
> <span data-ttu-id="a1002-103">**EF6 以降のみ** - このページで説明する機能、API などは、Entity Framework 6 で導入されました。</span><span class="sxs-lookup"><span data-stu-id="a1002-103">**EF6 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 6.</span></span> <span data-ttu-id="a1002-104">以前のバージョンを使用している場合、一部またはすべての情報は適用されません。</span><span class="sxs-lookup"><span data-stu-id="a1002-104">If you are using an earlier version, some or all of the information does not apply.</span></span>  

<span data-ttu-id="a1002-105">ときにいつでも Entity Framework コマンドを送信、データベースにこのコマンドは、Entity Framework 6 では、以降は、アプリケーション コードで受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="a1002-105">Starting with Entity Framework 6, anytime Entity Framework sends a command to the database this command can be intercepted by application code.</span></span> <span data-ttu-id="a1002-106">これは、SQL では、ログ記録が最もよく使用されますが、変更、または、コマンドを中止するも使用できます。</span><span class="sxs-lookup"><span data-stu-id="a1002-106">This is most commonly used for logging SQL, but can also be used to modify or abort the command.</span></span>  

<span data-ttu-id="a1002-107">具体的には、EF が含まれます。</span><span class="sxs-lookup"><span data-stu-id="a1002-107">Specifically, EF includes:</span></span>  

- <span data-ttu-id="a1002-108">LINQ to SQL で DataContext.Log のようなコンテキストのログ プロパティ</span><span class="sxs-lookup"><span data-stu-id="a1002-108">A Log property for the context similar to DataContext.Log in LINQ to SQL</span></span>  
- <span data-ttu-id="a1002-109">コンテンツと、ログに送信される出力の書式設定をカスタマイズするためのメカニズム</span><span class="sxs-lookup"><span data-stu-id="a1002-109">A mechanism to customize the content and formatting of the output sent to the log</span></span>  
- <span data-ttu-id="a1002-110">コントロールと柔軟性を提供する傍受のための低レベルの構成要素</span><span class="sxs-lookup"><span data-stu-id="a1002-110">Low-level building blocks for interception giving greater control/flexibility</span></span>  

## <a name="context-log-property"></a><span data-ttu-id="a1002-111">コンテキストのログ プロパティ</span><span class="sxs-lookup"><span data-stu-id="a1002-111">Context Log property</span></span>  

<span data-ttu-id="a1002-112">DbContext.Database.Log プロパティは、文字列を受け取る任意のメソッドのデリゲートを設定できます。</span><span class="sxs-lookup"><span data-stu-id="a1002-112">The DbContext.Database.Log property can be set to a delegate for any method that takes a string.</span></span> <span data-ttu-id="a1002-113">最もよくその TextWriter の「書き込み」メソッドに設定することで、TextWriter に使用されます。</span><span class="sxs-lookup"><span data-stu-id="a1002-113">Most commonly it is used with any TextWriter by setting it to the “Write” method of that TextWriter.</span></span> <span data-ttu-id="a1002-114">現在のコンテキストによって生成されたすべての SQL は、そのライターに記録されます。</span><span class="sxs-lookup"><span data-stu-id="a1002-114">All SQL generated by the current context will be logged to that writer.</span></span> <span data-ttu-id="a1002-115">たとえば、次のコードは SQL をコンソールにログインします。</span><span class="sxs-lookup"><span data-stu-id="a1002-115">For example, the following code will log SQL to the console:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    // Your code here...
}
```  

<span data-ttu-id="a1002-116">そのコンテキストに注意してください。Console.Write Database.Log が設定されます。</span><span class="sxs-lookup"><span data-stu-id="a1002-116">Notice that context.Database.Log is set to Console.Write.</span></span> <span data-ttu-id="a1002-117">これは、すべての SQL をコンソールにログインするために必要です。</span><span class="sxs-lookup"><span data-stu-id="a1002-117">This is all that is needed to log SQL to the console.</span></span>  

### <a name="example-output"></a><span data-ttu-id="a1002-118">サンプルの出力</span><span class="sxs-lookup"><span data-stu-id="a1002-118">Example output</span></span>  

<span data-ttu-id="a1002-119">何らかの出力を確認できるようにしましょうクエリ/挿入/更新する単純なコードを追加します。</span><span class="sxs-lookup"><span data-stu-id="a1002-119">Let’s add some simple query/insert/update code so that we can see some output:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    var blog = context.Blogs.First(b => b.Title == "One Unicorn");

    blog.Posts.First().Title = "Green Eggs and Ham";

    blog.Posts.Add(new Post { Title = "I do not like them!" });

    context.SaveChangesAsync().Wait();
}
```  

<span data-ttu-id="a1002-120">これにより、次の出力が生成されます。</span><span class="sxs-lookup"><span data-stu-id="a1002-120">This will generate the following output:</span></span>  

``` SQL
SELECT TOP (1)
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title]
    FROM [dbo].[Blogs] AS [Extent1]
    WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 4 ms with result: SqlDataReader

SELECT
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title],
    [Extent1].[BlogId] AS [BlogId]
    FROM [dbo].[Posts] AS [Extent1]
    WHERE [Extent1].[BlogId] = @EntityKeyValue1
-- EntityKeyValue1: '1' (Type = Int32)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader

UPDATE [dbo].[Posts]
SET [Title] = @0
WHERE ([Id] = @1)
-- @0: 'Green Eggs and Ham' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 12 ms with result: 1

INSERT [dbo].[Posts]([Title], [BlogId])
VALUES (@0, @1)
SELECT [Id]
FROM [dbo].[Posts]
WHERE @@ROWCOUNT > 0 AND [Id] = scope_identity()
-- @0: 'I do not like them!' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader
```  

<span data-ttu-id="a1002-121">(これは、データベースの初期化が既に過ぎていると仮定すると出力であることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="a1002-121">(Note that this is the output assuming any database initialization has already happened.</span></span> <span data-ttu-id="a1002-122">データベースの初期化が既に行われていない場合がありますし、移行のすべての作業を表示、はるかに多くの出力が内部でのチェックまたは新しいデータベースを作成します。)</span><span class="sxs-lookup"><span data-stu-id="a1002-122">If database initialization had not already happened then there would be a lot more output showing all the work Migrations does under the covers to check for or create a new database.)</span></span>  

### <a name="what-gets-logged"></a><span data-ttu-id="a1002-123">ログに記録内容を取得しますか。</span><span class="sxs-lookup"><span data-stu-id="a1002-123">What gets logged?</span></span>  

<span data-ttu-id="a1002-124">ときにログ プロパティの設定は、次のすべてのログに記録されます。</span><span class="sxs-lookup"><span data-stu-id="a1002-124">When the Log property is set all of the following will be logged:</span></span>  

- <span data-ttu-id="a1002-125">コマンドのさまざまな種類のすべての SQL です。</span><span class="sxs-lookup"><span data-stu-id="a1002-125">SQL for all different kinds of commands.</span></span> <span data-ttu-id="a1002-126">例えば:</span><span class="sxs-lookup"><span data-stu-id="a1002-126">For example:</span></span>  
    - <span data-ttu-id="a1002-127">通常の LINQ クエリ、eSQL クエリ、および SqlQuery などのメソッドからの生のクエリを含むクエリ</span><span class="sxs-lookup"><span data-stu-id="a1002-127">Queries, including normal LINQ queries, eSQL queries, and raw queries from methods such as SqlQuery</span></span>  
    - <span data-ttu-id="a1002-128">挿入、更新、および SaveChanges の一部として生成された削除</span><span class="sxs-lookup"><span data-stu-id="a1002-128">Inserts, updates, and deletes generated as part of SaveChanges</span></span>  
    - <span data-ttu-id="a1002-129">リレーションシップの遅延読み込みによって生成されるものなどのクエリの読み込み</span><span class="sxs-lookup"><span data-stu-id="a1002-129">Relationship loading queries such as those generated by lazy loading</span></span>  
- <span data-ttu-id="a1002-130">パラメーター</span><span class="sxs-lookup"><span data-stu-id="a1002-130">Parameters</span></span>  
- <span data-ttu-id="a1002-131">コマンドが非同期的に実行されているかどうか</span><span class="sxs-lookup"><span data-stu-id="a1002-131">Whether or not the command is being executed asynchronously</span></span>  
- <span data-ttu-id="a1002-132">コマンドが実行を開始したことを示すタイムスタンプ</span><span class="sxs-lookup"><span data-stu-id="a1002-132">A timestamp indicating when the command started executing</span></span>  
- <span data-ttu-id="a1002-133">例外をスローするか、非同期コマンドは正常に完了しましたが失敗しました、かどうかが取り消されました</span><span class="sxs-lookup"><span data-stu-id="a1002-133">Whether or not the command completed successfully, failed by throwing an exception, or, for async, was canceled</span></span>  
- <span data-ttu-id="a1002-134">結果の値のいくつかを示す値</span><span class="sxs-lookup"><span data-stu-id="a1002-134">Some indication of the result value</span></span>  
- <span data-ttu-id="a1002-135">コマンドを実行するのに要した概算の時間。</span><span class="sxs-lookup"><span data-stu-id="a1002-135">The approximate amount of time it took to execute the command.</span></span> <span data-ttu-id="a1002-136">結果オブジェクトを取得するコマンドの送信からの時間であるに注意してください。</span><span class="sxs-lookup"><span data-stu-id="a1002-136">Note that this is the time from sending the command to getting the result object back.</span></span> <span data-ttu-id="a1002-137">結果の読み取りに時間は含まれません。</span><span class="sxs-lookup"><span data-stu-id="a1002-137">It does not include time to read the results.</span></span>  

<span data-ttu-id="a1002-138">上記の例の出力を見ると、各ログに記録する 4 つのコマンドは。</span><span class="sxs-lookup"><span data-stu-id="a1002-138">Looking at the example output above, each of the four commands logged are:</span></span>  

- <span data-ttu-id="a1002-139">クエリのコンテキストへの呼び出しの結果します。Blogs.First</span><span class="sxs-lookup"><span data-stu-id="a1002-139">The query resulting from the call to context.Blogs.First</span></span>  
    - <span data-ttu-id="a1002-140">メソッドは、SQL を取得するためには、このクエリの動作しません ToString"First"が提供しないこと、IQueryable を ToString を呼び出すことができますに注意してください。</span><span class="sxs-lookup"><span data-stu-id="a1002-140">Notice that the ToString method of getting the SQL would not have worked for this query since “First” does not provide an IQueryable on which ToString could be called</span></span>  
- <span data-ttu-id="a1002-141">ブログの遅延読み込みをクエリします。投稿</span><span class="sxs-lookup"><span data-stu-id="a1002-141">The query resulting from the lazy-loading of blog.Posts</span></span>  
    - <span data-ttu-id="a1002-142">どの遅延読み込みのキー値のパラメーターの詳細が行われることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="a1002-142">Notice the parameter details for the key value for which lazy loading is happening</span></span>  
    - <span data-ttu-id="a1002-143">既定以外の値に設定されているパラメーターのプロパティのみが記録されます。</span><span class="sxs-lookup"><span data-stu-id="a1002-143">Only properties of the parameter that are set to non-default values are logged.</span></span> <span data-ttu-id="a1002-144">たとえば、サイズ プロパティのみのように 0 でないかどうかは。</span><span class="sxs-lookup"><span data-stu-id="a1002-144">For example, the Size property is only shown if it is non-zero.</span></span>  
- <span data-ttu-id="a1002-145">SaveChangesAsync; から結果として 2 つのコマンド1 つは、更新、挿入する新しい投稿を追加する他の投稿のタイトルを変更するには</span><span class="sxs-lookup"><span data-stu-id="a1002-145">Two commands resulting from SaveChangesAsync; one for the update to change a post title, the other for an insert to add a new post</span></span>  
    - <span data-ttu-id="a1002-146">FK とタイトルのプロパティのパラメーターの詳細に注意してください。</span><span class="sxs-lookup"><span data-stu-id="a1002-146">Notice the parameter details for the FK and Title properties</span></span>  
    - <span data-ttu-id="a1002-147">これらのコマンドを非同期的に実行されていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="a1002-147">Notice that these commands are being executed asynchronously</span></span>  

### <a name="logging-to-different-places"></a><span data-ttu-id="a1002-148">別の場所にログ記録</span><span class="sxs-lookup"><span data-stu-id="a1002-148">Logging to different places</span></span>  

<span data-ttu-id="a1002-149">上記のログ記録をコンソールはとても簡単です。</span><span class="sxs-lookup"><span data-stu-id="a1002-149">As shown above logging to the console is super easy.</span></span> <span data-ttu-id="a1002-150">簡単にメモリやファイルなどさまざまな種類を使用してログインの[TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx)します。</span><span class="sxs-lookup"><span data-stu-id="a1002-150">It’s also easy to log to memory, file, etc. by using different kinds of [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span></span>  

<span data-ttu-id="a1002-151">LINQ to SQL で LINQ to SQL のログ プロパティが TextWriter で実際のオブジェクト (たとえば、Console.Out) 中にログ設定されます (たとえば、文字列を受け取るメソッドに EF に注意が使い慣れている場合、Console.Write または Console.Out.Write)。</span><span class="sxs-lookup"><span data-stu-id="a1002-151">If you are familiar with LINQ to SQL you might notice that in LINQ to SQL the Log property is set to the actual TextWriter object (for example, Console.Out) while in EF the Log property is set to a method that accepts a string (for example, Console.Write or Console.Out.Write).</span></span> <span data-ttu-id="a1002-152">この理由は、文字列をシンクとして機能するすべてのデリゲートをそのまま使用して EF TextWriter からを分離するためです。</span><span class="sxs-lookup"><span data-stu-id="a1002-152">The reason for this is to decouple EF from TextWriter by accepting any delegate that can act as a sink for strings.</span></span> <span data-ttu-id="a1002-153">たとえば、いくつかのログ記録フレームワークが既にあることと、ログ記録メソッドを定義します次のようにします。</span><span class="sxs-lookup"><span data-stu-id="a1002-153">For example, imagine that you already have some logging framework and it defines a logging method like so:</span></span>  

``` csharp
public class MyLogger
{
    public void Log(string component, string message)
    {
        Console.WriteLine("Component: {0} Message: {1} ", component, message);
    }
}
```  

<span data-ttu-id="a1002-154">このような EF のログ プロパティにこれフックする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a1002-154">This could be hooked up to the EF Log property like this:</span></span>  

``` csharp
var logger = new MyLogger();
context.Database.Log = s => logger.Log("EFApp", s);
```  

### <a name="result-logging"></a><span data-ttu-id="a1002-155">結果のログ記録</span><span class="sxs-lookup"><span data-stu-id="a1002-155">Result logging</span></span>  

<span data-ttu-id="a1002-156">既定のロガー ログ コマンド テキスト (SQL)、パラメーター、および「実行」の行のタイムスタンプを持つデータベースにコマンドが送信される前にします。</span><span class="sxs-lookup"><span data-stu-id="a1002-156">The default logger logs command text (SQL), parameters, and the “Executing” line with a timestamp before the command is sent to the database.</span></span> <span data-ttu-id="a1002-157">経過時間を含む「完了」の行では、コマンドのログに記録された次の実行です。</span><span class="sxs-lookup"><span data-stu-id="a1002-157">A “completed” line containing elapsed time is logged following execution of the command.</span></span>  

<span data-ttu-id="a1002-158">非同期タスク実際に完了、失敗した場合、またはキャンセルされるまでは、非同期の「完了」の行をコマンドには記録されません。</span><span class="sxs-lookup"><span data-stu-id="a1002-158">Note that for async commands the “completed” line is not logged until the async task actually completes, fails, or is canceled.</span></span>  

<span data-ttu-id="a1002-159">「完了」の行には、コマンドと実行が成功したかどうかの種類に応じて、異なる情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="a1002-159">The “completed” line contains different information depending on the type of command and whether or not execution was successful.</span></span>  

#### <a name="successful-execution"></a><span data-ttu-id="a1002-160">正常に実行</span><span class="sxs-lookup"><span data-stu-id="a1002-160">Successful execution</span></span>  

<span data-ttu-id="a1002-161">出力を正常に完了するためのコマンドは"結果を使用した ms x で完了しました:"後に、結果の内容の一部を示す値。</span><span class="sxs-lookup"><span data-stu-id="a1002-161">For commands that complete successfully the output is “Completed in x ms with result: “ followed by some indication of what the result was.</span></span> <span data-ttu-id="a1002-162">データ リーダーの結果を返すコマンドを示す値は、型[DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx)が返されます。</span><span class="sxs-lookup"><span data-stu-id="a1002-162">For commands that return a data reader the result indication is the type of [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) returned.</span></span> <span data-ttu-id="a1002-163">更新プログラムなどの整数値を返すコマンドに示す結果上に示したコマンドは整数になります。</span><span class="sxs-lookup"><span data-stu-id="a1002-163">For commands that return an integer value such as the update command shown above the result shown is that integer.</span></span>  

#### <a name="failed-execution"></a><span data-ttu-id="a1002-164">失敗した実行</span><span class="sxs-lookup"><span data-stu-id="a1002-164">Failed execution</span></span>  

<span data-ttu-id="a1002-165">例外をスローして失敗したコマンドの出力には、例外からのメッセージが含まれています。</span><span class="sxs-lookup"><span data-stu-id="a1002-165">For commands that fail by throwing an exception, the output contains the message from the exception.</span></span> <span data-ttu-id="a1002-166">たとえば、SqlQuery が存在するテーブルに対するクエリを使用してログで結果の出力はこのようなもの。</span><span class="sxs-lookup"><span data-stu-id="a1002-166">For example, using SqlQuery to query against a table that does exist will result in log output something like this:</span></span>  

``` SQL
SELECT * from ThisTableIsMissing
-- Executing at 5/13/2013 10:19:05 AM
-- Failed in 1 ms with error: Invalid object name 'ThisTableIsMissing'.
```  

#### <a name="canceled-execution"></a><span data-ttu-id="a1002-167">取り消された実行</span><span class="sxs-lookup"><span data-stu-id="a1002-167">Canceled execution</span></span>  

<span data-ttu-id="a1002-168">非同期コマンドが、タスクはキャンセル結果でした失敗、例外のためにこれは、基になる ADO.NET プロバイダー多くの場合、キャンセルを試行したときに。</span><span class="sxs-lookup"><span data-stu-id="a1002-168">For async commands where the task is canceled the result could be failure with an exception, since this is what the underlying ADO.NET provider often does when an attempt is made to cancel.</span></span> <span data-ttu-id="a1002-169">そうしない場合、出力は次のようになりますし、タスクは正常にキャンセルします。</span><span class="sxs-lookup"><span data-stu-id="a1002-169">If this doesn’t happen and the task is canceled cleanly then the output will look something like this:</span></span>  

```  
update Blogs set Title = 'No' where Id = -1
-- Executing asynchronously at 5/13/2013 10:21:10 AM
-- Canceled in 1 ms
```  

## <a name="changing-log-content-and-formatting"></a><span data-ttu-id="a1002-170">ログの内容を変更して、書式設定</span><span class="sxs-lookup"><span data-stu-id="a1002-170">Changing log content and formatting</span></span>  

### <a name="databaselogformatter"></a><span data-ttu-id="a1002-171">DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="a1002-171">DatabaseLogFormatter</span></span>  

<span data-ttu-id="a1002-172">実際には DatabaseLogFormatter オブジェクトのプロパティは、Database.Log を使用します。</span><span class="sxs-lookup"><span data-stu-id="a1002-172">Under the covers the Database.Log property makes use of a DatabaseLogFormatter object.</span></span> <span data-ttu-id="a1002-173">このオブジェクトは、文字列と DbContext をデリゲートに IDbCommandInterceptor 実装 (下記参照) を効果的にバインドします。</span><span class="sxs-lookup"><span data-stu-id="a1002-173">This object effectively binds an IDbCommandInterceptor implementation (see below) to a delegate that accepts strings and a DbContext.</span></span> <span data-ttu-id="a1002-174">これは、ある DatabaseLogFormatter メソッドによって呼び出されるコマンドの実行の前後に EF を意味します。</span><span class="sxs-lookup"><span data-stu-id="a1002-174">This means that methods on DatabaseLogFormatter are called before and after the execution of commands by EF.</span></span> <span data-ttu-id="a1002-175">これらの DatabaseLogFormatter メソッドは、収集し、ログ出力を書式設定し、代理人に送信します。</span><span class="sxs-lookup"><span data-stu-id="a1002-175">These DatabaseLogFormatter methods gather and format log output and send it to the delegate.</span></span>  

### <a name="customizing-databaselogformatter"></a><span data-ttu-id="a1002-176">DatabaseLogFormatter をカスタマイズします。</span><span class="sxs-lookup"><span data-stu-id="a1002-176">Customizing DatabaseLogFormatter</span></span>  

<span data-ttu-id="a1002-177">DatabaseLogFormatter から派生し、適切なメソッドを上書きする新しいクラスを作成してログ内容と書式設定方法の変更を実現できます。</span><span class="sxs-lookup"><span data-stu-id="a1002-177">Changing what is logged and how it is formatted can be achieved by creating a new class that derives from DatabaseLogFormatter and overrides methods as appropriate.</span></span> <span data-ttu-id="a1002-178">オーバーライドする最も一般的な方法を示します。</span><span class="sxs-lookup"><span data-stu-id="a1002-178">The most common methods to override are:</span></span>  

- <span data-ttu-id="a1002-179">LogCommand – これをオーバーライドして、それらが実行される前にコマンドを記録する方法を変更します。</span><span class="sxs-lookup"><span data-stu-id="a1002-179">LogCommand – Override this to change how commands are logged before they are executed.</span></span> <span data-ttu-id="a1002-180">既定で LogCommand は各パラメーターの LogParameter を呼び出すオーバーライドで同じ処理を実行または代わりに異なる方法でパラメーターを処理することができます。</span><span class="sxs-lookup"><span data-stu-id="a1002-180">By default LogCommand calls LogParameter for each parameter; you may choose to do the same in your override or handle parameters differently instead.</span></span>  
- <span data-ttu-id="a1002-181">LogResult – これをオーバーライドしてから、コマンドの実行結果を記録する方法を変更します。</span><span class="sxs-lookup"><span data-stu-id="a1002-181">LogResult – Override this to change how the outcome from executing a command is logged.</span></span>  
- <span data-ttu-id="a1002-182">LogParameter – これをオーバーライドして、書式設定とパラメーターのログ記録の内容を変更します。</span><span class="sxs-lookup"><span data-stu-id="a1002-182">LogParameter – Override this to change the formatting and content of parameter logging.</span></span>  

<span data-ttu-id="a1002-183">たとえば、各コマンドは、データベースに送信される前に、1 行だけを記録したいとします。</span><span class="sxs-lookup"><span data-stu-id="a1002-183">For example, suppose we wanted to log just a single line before each command is sent to the database.</span></span> <span data-ttu-id="a1002-184">これは、2 つの上書きを実行できます。</span><span class="sxs-lookup"><span data-stu-id="a1002-184">This can be done with two overrides:</span></span>  

- <span data-ttu-id="a1002-185">書式設定および SQL の 1 つの行を記述する LogCommand をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="a1002-185">Override LogCommand to format and write the single line of SQL</span></span>  
- <span data-ttu-id="a1002-186">何もしない LogResult をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="a1002-186">Override LogResult to do nothing.</span></span>  

<span data-ttu-id="a1002-187">コードは、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="a1002-187">The code would look something like this:</span></span>

``` csharp
public class OneLineFormatter : DatabaseLogFormatter
{
    public OneLineFormatter(DbContext context, Action<string> writeAction)
        : base(context, writeAction)
    {
    }

    public override void LogCommand<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        Write(string.Format(
            "Context '{0}' is executing command '{1}'{2}",
            Context.GetType().Name,
            command.CommandText.Replace(Environment.NewLine, ""),
            Environment.NewLine));
    }

    public override void LogResult<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
    }
}
```  

<span data-ttu-id="a1002-188">ログインをかけるだけで構成された書き込みのデリゲートに出力を送信 Write メソッドを出力します。</span><span class="sxs-lookup"><span data-stu-id="a1002-188">To log output simply call the Write method which will send output to the configured write delegate.</span></span>  

<span data-ttu-id="a1002-189">(このコードで改行の例と同様の単純な削除はことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="a1002-189">(Note that this code does simplistic removal of line breaks just as an example.</span></span> <span data-ttu-id="a1002-190">可能性があります機能複雑な SQL を表示します。)</span><span class="sxs-lookup"><span data-stu-id="a1002-190">It will likely not work well for viewing complex SQL.)</span></span>  

### <a name="setting-the-databaselogformatter"></a><span data-ttu-id="a1002-191">設定、DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="a1002-191">Setting the DatabaseLogFormatter</span></span>  

<span data-ttu-id="a1002-192">その新しい DatabaseLogFormatter クラスを作成した後は、EF に登録する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a1002-192">Once a new DatabaseLogFormatter class has been created it needs to be registered with EF.</span></span> <span data-ttu-id="a1002-193">これは、コード ベースの構成を使用します。</span><span class="sxs-lookup"><span data-stu-id="a1002-193">This is done using code-based configuration.</span></span> <span data-ttu-id="a1002-194">一言では、DbContext クラスと同じアセンブリ内の DbConfiguration から派生した新しいクラスを作成して、この新しいクラスのコンス トラクターで呼び出して SetDatabaseLogFormatter を意味します。</span><span class="sxs-lookup"><span data-stu-id="a1002-194">In a nutshell this means creating a new class that derives from DbConfiguration in the same assembly as your DbContext class and then calling SetDatabaseLogFormatter in the constructor of this new class.</span></span> <span data-ttu-id="a1002-195">例えば:</span><span class="sxs-lookup"><span data-stu-id="a1002-195">For example:</span></span>  

``` csharp
public class MyDbConfiguration : DbConfiguration
{
    public MyDbConfiguration()
    {
        SetDatabaseLogFormatter(
            (context, writeAction) => new OneLineFormatter(context, writeAction));
    }
}
```  

### <a name="using-the-new-databaselogformatter"></a><span data-ttu-id="a1002-196">新しい DatabaseLogFormatter を使用します。</span><span class="sxs-lookup"><span data-stu-id="a1002-196">Using the new DatabaseLogFormatter</span></span>  

<span data-ttu-id="a1002-197">この新しい DatabaseLogFormatter Database.Log が設定されているときにいつでも使用されます。</span><span class="sxs-lookup"><span data-stu-id="a1002-197">This new DatabaseLogFormatter will now be used anytime Database.Log is set.</span></span> <span data-ttu-id="a1002-198">そのため、第 1 部からコードを実行しているが、次の出力では発生ようになりました。</span><span class="sxs-lookup"><span data-stu-id="a1002-198">So, running the code from part 1 will now result in the following output:</span></span>  

```  
Context 'BlogContext' is executing command 'SELECT TOP (1) [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title]FROM [dbo].[Blogs] AS [Extent1]WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)'
Context 'BlogContext' is executing command 'SELECT [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title], [Extent1].[BlogId] AS [BlogId]FROM [dbo].[Posts] AS [Extent1]WHERE [Extent1].[BlogId] = @EntityKeyValue1'
Context 'BlogContext' is executing command 'update [dbo].[Posts]set [Title] = @0where ([Id] = @1)'
Context 'BlogContext' is executing command 'insert [dbo].[Posts]([Title], [BlogId])values (@0, @1)select [Id]from [dbo].[Posts]where @@rowcount > 0 and [Id] = scope_identity()'
```  

## <a name="interception-building-blocks"></a><span data-ttu-id="a1002-199">インターセプション構成要素</span><span class="sxs-lookup"><span data-stu-id="a1002-199">Interception building blocks</span></span>  

<span data-ttu-id="a1002-200">これまでに DbContext.Database.Log を使用して、EF によって生成される SQL ログに記録する方法が説明しました。</span><span class="sxs-lookup"><span data-stu-id="a1002-200">So far we have looked at how to use DbContext.Database.Log to log the SQL generated by EF.</span></span> <span data-ttu-id="a1002-201">このコードは、一般的な傍受のための低レベルの構成要素を実際には比較的薄いファサードです。</span><span class="sxs-lookup"><span data-stu-id="a1002-201">But this code is actually a relatively thin façade over some low-level building blocks for more general interception.</span></span>  

### <a name="interception-interfaces"></a><span data-ttu-id="a1002-202">インターセプション インターフェイス</span><span class="sxs-lookup"><span data-stu-id="a1002-202">Interception interfaces</span></span>  

<span data-ttu-id="a1002-203">インターセプション コード インターセプション インターフェイスの概念が構築されています。</span><span class="sxs-lookup"><span data-stu-id="a1002-203">The interception code is built around the concept of interception interfaces.</span></span> <span data-ttu-id="a1002-204">これらのインターフェイスは IDbInterceptor から継承し、EF が何らかのアクションを実行するときに呼び出されるメソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="a1002-204">These interfaces inherit from IDbInterceptor and define methods that are called when EF performs some action.</span></span> <span data-ttu-id="a1002-205">目的は、1 つのインターフェイスが傍受されないオブジェクトの種類ごとにです。</span><span class="sxs-lookup"><span data-stu-id="a1002-205">The intent is to have one interface per type of object being intercepted.</span></span> <span data-ttu-id="a1002-206">たとえば、IDbCommandInterceptor インターフェイスは、EF は ExecuteNonQuery、ExecuteScalar、ExecuteReader、および関連するメソッドの呼び出し前に呼び出されるメソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="a1002-206">For example, the IDbCommandInterceptor interface defines methods that are called before EF makes a call to ExecuteNonQuery, ExecuteScalar, ExecuteReader, and related methods.</span></span> <span data-ttu-id="a1002-207">同様に、インターフェイスは、これらの各操作が完了したときに呼び出されるメソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="a1002-207">Likewise, the interface defines methods that are called when each of these operations completes.</span></span> <span data-ttu-id="a1002-208">これまで見てきた上を DatabaseLogFormatter クラスは、コマンドをログには、このインターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="a1002-208">The DatabaseLogFormatter class that we looked at above implements this interface to log commands.</span></span>  

### <a name="the-interception-context"></a><span data-ttu-id="a1002-209">インターセプトのコンテキスト</span><span class="sxs-lookup"><span data-stu-id="a1002-209">The interception context</span></span>  

<span data-ttu-id="a1002-210">インターセプター インターフェイスのいずれかで定義されているメソッドで検索することことすべての呼び出しは指定された型 DbInterceptionContext のオブジェクトまたは何らかの種類から派生したこの DbCommandInterceptionContext など明らかな\<\>します。</span><span class="sxs-lookup"><span data-stu-id="a1002-210">Looking at the methods defined on any of the interceptor interfaces it is apparent that every call is given an object of type DbInterceptionContext or some type derived from this such as DbCommandInterceptionContext\<\>.</span></span> <span data-ttu-id="a1002-211">このオブジェクトには、EF がかかっている操作に関するコンテキスト情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="a1002-211">This object contains contextual information about the action that EF is taking.</span></span> <span data-ttu-id="a1002-212">たとえば、DbContext に代わって、この操作を実行中は場合、DbContext は、DbInterceptionContext で含まし。</span><span class="sxs-lookup"><span data-stu-id="a1002-212">For example, if the action is being taken on behalf of a DbContext, then the DbContext is included in the DbInterceptionContext.</span></span> <span data-ttu-id="a1002-213">同様に、非同期的に実行されているコマンドについては、DbCommandInterceptionContext にへの IsAsync フラグが設定します。</span><span class="sxs-lookup"><span data-stu-id="a1002-213">Similarly, for commands that are being executed asynchronously, the IsAsync flag is set on DbCommandInterceptionContext.</span></span>  

### <a name="result-handling"></a><span data-ttu-id="a1002-214">結果の処理</span><span class="sxs-lookup"><span data-stu-id="a1002-214">Result handling</span></span>  

<span data-ttu-id="a1002-215">DbCommandInterceptionContext\< \>クラスには、結果、OriginalResult、例外、および OriginalException と呼ばれるプロパティが含まれています。</span><span class="sxs-lookup"><span data-stu-id="a1002-215">The DbCommandInterceptionContext\<\> class contains a properties called Result, OriginalResult, Exception, and OriginalException.</span></span> <span data-ttu-id="a1002-216">これらのプロパティ設定に null/0、操作を実行する前に呼び出されるインターセプターのメソッドを呼び出し、つまりの.メソッドを実行します。</span><span class="sxs-lookup"><span data-stu-id="a1002-216">These properties are set to null/zero for calls to the interception methods that are called before the operation is executed — that is, for the …Executing methods.</span></span> <span data-ttu-id="a1002-217">操作が実行され、成功すると場合、結果と OriginalResult し、設定操作の結果にするされます。</span><span class="sxs-lookup"><span data-stu-id="a1002-217">If the operation is executed and succeeds, then Result and OriginalResult are set to the result of the operation.</span></span> <span data-ttu-id="a1002-218">操作が実行された後に呼び出されるインターセプターのメソッドで、これらの値を確認しできます-がの.メソッドを実行します。</span><span class="sxs-lookup"><span data-stu-id="a1002-218">These values can then be observed in the interception methods that are called after the operation has executed — that is, on the …Executed methods.</span></span> <span data-ttu-id="a1002-219">同様に、操作をスローする場合、例外と OriginalException プロパティは設定されます。</span><span class="sxs-lookup"><span data-stu-id="a1002-219">Likewise, if the operation throws, then the Exception and OriginalException properties will be set.</span></span>  

#### <a name="suppressing-execution"></a><span data-ttu-id="a1002-220">実行を抑制します。</span><span class="sxs-lookup"><span data-stu-id="a1002-220">Suppressing execution</span></span>  

<span data-ttu-id="a1002-221">コマンドが実行される前に、インターセプターが、Result プロパティを設定かどうか (のいずれかで、...メソッドの実行) し、EF は、コマンドを実際に実行を試行しませんが、代わりにだけ、結果セット。</span><span class="sxs-lookup"><span data-stu-id="a1002-221">If an interceptor sets the Result property before the command has executed (in one of the …Executing methods) then EF will not attempt to actually execute the command, but will instead just use the result set.</span></span> <span data-ttu-id="a1002-222">つまり、インターセプターは、コマンドの実行を抑制するが、続行コマンドが実行された場合、EF があります。</span><span class="sxs-lookup"><span data-stu-id="a1002-222">In other words, the interceptor can suppress execution of the command but have EF continue as if the command had been executed.</span></span>  

<span data-ttu-id="a1002-223">これを使用する方法の例では、ラッピング プロバイダーでコマンドをバッチ処理が実現していました。</span><span class="sxs-lookup"><span data-stu-id="a1002-223">An example of how this might be used is the command batching that has traditionally been done with a wrapping provider.</span></span> <span data-ttu-id="a1002-224">インターセプターは後で実行するためのコマンドをバッチとして保存しますを通常どおり、コマンドを実行した EF「ふり」は。</span><span class="sxs-lookup"><span data-stu-id="a1002-224">The interceptor would store the command for later execution as a batch but would “pretend” to EF that the command had executed as normal.</span></span> <span data-ttu-id="a1002-225">、バッチ処理を実装するためにそれ以上が必要ですが、これは、傍受される結果の変更を使用する方法の例に注意してください。</span><span class="sxs-lookup"><span data-stu-id="a1002-225">Note that it requires more than this to implement batching, but this is an example of how changing the interception result might be used.</span></span>  

<span data-ttu-id="a1002-226">いずれかで例外のプロパティを設定して実行を抑制することも、.メソッドを実行します。</span><span class="sxs-lookup"><span data-stu-id="a1002-226">Execution can also be suppressed by setting the Exception property in one of the …Executing methods.</span></span> <span data-ttu-id="a1002-227">これにより、EF に指定した例外をスローして、操作の実行に失敗したかのように続行されます。</span><span class="sxs-lookup"><span data-stu-id="a1002-227">This causes EF to continue as if execution of the operation had failed by throwing the given exception.</span></span> <span data-ttu-id="a1002-228">これが、もちろん、原因でクラッシュし、アプリケーションが一時的な例外や EF によって処理されるその他のいくつかの例外があります。</span><span class="sxs-lookup"><span data-stu-id="a1002-228">This may, of course, cause the application to crash, but it may also be a transient exception or some other exception that is handled by EF.</span></span> <span data-ttu-id="a1002-229">たとえば、このされる可能性がありますテスト環境でコマンドの実行が失敗したときに、アプリケーションの動作をテストします。</span><span class="sxs-lookup"><span data-stu-id="a1002-229">For example, this could be used in test environments to test the behavior of an application when command execution fails.</span></span>  

#### <a name="changing-the-result-after-execution"></a><span data-ttu-id="a1002-230">実行後、結果を変更します。</span><span class="sxs-lookup"><span data-stu-id="a1002-230">Changing the result after execution</span></span>  

<span data-ttu-id="a1002-231">コマンドが実行された後にインターセプターがかどうかに結果のプロパティを設定 (のいずれかで、...メソッドの実行)、EF は実際には、操作から返された結果ではなく、変更された結果を使用します。</span><span class="sxs-lookup"><span data-stu-id="a1002-231">If an interceptor sets the Result property after the command has executed (in one of the …Executed methods) then EF will use the changed result instead of the result that was actually returned from the operation.</span></span> <span data-ttu-id="a1002-232">同様に、インターセプターは、コマンドが実行された後に、例外のプロパティを設定、されている場合、EF セット例外がスローされます、操作は、例外をスローしていた場合。</span><span class="sxs-lookup"><span data-stu-id="a1002-232">Similarly, if an interceptor sets the Exception property after the command has executed, then EF will throw the set exception as if the operation had thrown the exception.</span></span>  

<span data-ttu-id="a1002-233">インターセプターは、例外をスローしないことを示す null に例外プロパティを設定することができますも。</span><span class="sxs-lookup"><span data-stu-id="a1002-233">An interceptor can also set the Exception property to null to indicate that no exception should be thrown.</span></span> <span data-ttu-id="a1002-234">これは、操作の実行に失敗しましたが、インターセプターが EF 操作が正常に完了した場合、続行する場合に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="a1002-234">This can be useful if execution of the operation failed but the interceptor wishes EF to continue as if the operation had succeeded.</span></span> <span data-ttu-id="a1002-235">これは通常必要もあります EF がある継続を使用するいくつかの結果値を持つように、結果を設定します。</span><span class="sxs-lookup"><span data-stu-id="a1002-235">This usually also involves setting the Result so that EF has some result value to work with as it continues.</span></span>  

#### <a name="originalresult-and-originalexception"></a><span data-ttu-id="a1002-236">OriginalResult と OriginalException</span><span class="sxs-lookup"><span data-stu-id="a1002-236">OriginalResult and OriginalException</span></span>  

<span data-ttu-id="a1002-237">EF の操作が実行された後に設定されます実行は失敗しなかった場合の結果と OriginalResult プロパティか、例外および OriginalException プロパティ実行例外で失敗しました。</span><span class="sxs-lookup"><span data-stu-id="a1002-237">After EF has executed an operation it will set either the Result and OriginalResult properties if execution did not fail or the Exception and OriginalException properties if execution failed with an exception.</span></span>  

<span data-ttu-id="a1002-238">OriginalResult と OriginalException プロパティは読み取り専用と、実際に操作を実行した後、EF によってのみ設定されます。</span><span class="sxs-lookup"><span data-stu-id="a1002-238">The OriginalResult and OriginalException properties are read-only and are only set by EF after actually executing an operation.</span></span> <span data-ttu-id="a1002-239">インターセプターでは、これらのプロパティを設定できません。</span><span class="sxs-lookup"><span data-stu-id="a1002-239">These properties cannot be set by interceptors.</span></span> <span data-ttu-id="a1002-240">つまり、インターセプターは、例外または結果では実際の例外ではなく他のいくつかのインターセプタによって設定されているか、操作を実行したときに発生した結果の間で区別できます。</span><span class="sxs-lookup"><span data-stu-id="a1002-240">This means that any interceptor can distinguish between an exception or result that has been set by some other interceptor as opposed to the real exception or result that occurred when the operation was executed.</span></span>  

### <a name="registering-interceptors"></a><span data-ttu-id="a1002-241">インターセプターを登録します。</span><span class="sxs-lookup"><span data-stu-id="a1002-241">Registering interceptors</span></span>  

<span data-ttu-id="a1002-242">インターセプトのインターフェイスを実装するクラスが作成されたら、DbInterception クラスを使用して EF で登録できます。</span><span class="sxs-lookup"><span data-stu-id="a1002-242">Once a class that implements one or more of the interception interfaces has been created it can be registered with EF using the DbInterception class.</span></span> <span data-ttu-id="a1002-243">例えば:</span><span class="sxs-lookup"><span data-stu-id="a1002-243">For example:</span></span>  

``` csharp
DbInterception.Add(new NLogCommandInterceptor());
```  

<span data-ttu-id="a1002-244">インターセプターは、DbConfiguration コード ベースの構成機構を使用して、アプリケーション ドメイン レベルで登録することもできます。</span><span class="sxs-lookup"><span data-stu-id="a1002-244">Interceptors can also be registered at the app-domain level using the DbConfiguration code-based configuration mechanism.</span></span>  

### <a name="example-logging-to-nlog"></a><span data-ttu-id="a1002-245">例: ログ NLog を</span><span class="sxs-lookup"><span data-stu-id="a1002-245">Example: Logging to NLog</span></span>  

<span data-ttu-id="a1002-246">まとめてみましょうすべてこれには、例を使用して IDbCommandInterceptor と[NLog](http://nlog-project.org/)に。</span><span class="sxs-lookup"><span data-stu-id="a1002-246">Let’s put all this together into an example that using IDbCommandInterceptor and [NLog](http://nlog-project.org/) to:</span></span>  

- <span data-ttu-id="a1002-247">ログの警告を非非同期的に実行される任意のコマンド</span><span class="sxs-lookup"><span data-stu-id="a1002-247">Log a warning for any command that is executed non-asynchronously</span></span>  
- <span data-ttu-id="a1002-248">実行されたときにスローする任意のコマンドのエラー ログに記録します。</span><span class="sxs-lookup"><span data-stu-id="a1002-248">Log an error for any command that throws when executed</span></span>  

<span data-ttu-id="a1002-249">上記のように登録する必要がありますが、ログ記録を行うクラスを次に示します。</span><span class="sxs-lookup"><span data-stu-id="a1002-249">Here’s the class that does the logging, which should be registered as shown above:</span></span>  

``` csharp
public class NLogCommandInterceptor : IDbCommandInterceptor
{
    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    public void NonQueryExecuting(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void NonQueryExecuted(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ReaderExecuting(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ReaderExecuted(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ScalarExecuting(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ScalarExecuted(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    private void LogIfNonAsync<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (!interceptionContext.IsAsync)
        {
            Logger.Warn("Non-async command used: {0}", command.CommandText);
        }
    }

    private void LogIfError<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (interceptionContext.Exception != null)
        {
            Logger.Error("Command {0} failed with exception {1}",
                command.CommandText, interceptionContext.Exception);
        }
    }
}
```  

<span data-ttu-id="a1002-250">このコードが傍受されるコンテキストを使用するコマンドを非非同期的に実行されているときに検出して、コマンドを実行中にエラーがある場合を検出する方法に注意してください。</span><span class="sxs-lookup"><span data-stu-id="a1002-250">Notice how this code uses the interception context to discover when a command is being executed non-asynchronously and to discover when there was an error executing a command.</span></span>  
