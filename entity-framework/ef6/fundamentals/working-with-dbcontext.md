---
title: DbContext の EF6 の使用
author: divega
ms.date: 10/23/2016
ms.assetid: b0e6bddc-8a87-4d51-b1cb-7756df938c23
ms.openlocfilehash: d961ffd8bed7f5b2f82dcfa30fc0241b7437be50
ms.sourcegitcommit: 2b787009fd5be5627f1189ee396e708cd130e07b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/13/2018
ms.locfileid: "45489064"
---
# <a name="working-with-dbcontext"></a>DbContext の使用

クエリ、挿入、更新、および .NET オブジェクトを使用してデータを削除する Entity Framework を使用するにはまずに[モデルを作成する](~/ef6/modeling/index.md)エンティティとデータベース内のテーブル モデルで定義されているリレーションシップにマップします。

アプリケーションの対話の主要なクラスは、モデルを作成したら、 `System.Data.Entity.DbContext` (コンテキストのクラスとも呼ばれます)。 モデルに関連付けられている DbContext を使用することができます。
- 書き込みし、クエリの実行   
- エンティティ オブジェクトとしてクエリ結果を具体化します。
- これらのオブジェクトに加えられた変更を追跡します。
- オブジェクトの変更、データベースをバックアップの保持します。
- メモリ内のオブジェクトを UI コントロールにバインド

このページには、コンテキスト クラスを管理する方法のいくつかのガイダンスが表示されます。  

## <a name="defining-a-dbcontext-derived-class"></a>DbContext 派生クラスを定義します。  

コンテキストを使用することをお勧めの方法では、DbContext から派生し、コンテキスト内の指定したエンティティのコレクションを表す DbSet プロパティを公開するクラスを定義します。 EF デザイナーを使用する場合、コンテキストが生成されます。 Code First で作業している場合は通常、コンテキスト自分で作成しました。  

``` csharp
public class ProductContext : DbContext
{
    public DbSet<Category> Categories { get; set; }
    public DbSet<Product> Products { get; set; }
}
```  

クエリを実行、追加は、コンテキストを使用すると、(を使用して`Add`または`Attach`メソッド) または削除 (を使用して`Remove`) これらのプロパティをコンテキスト内のエンティティ。 アクセス、`DbSet`コンテキスト オブジェクトのプロパティを指定した型のすべてのエンティティを返す開始クエリを表します。 だけプロパティへのアクセスは、クエリを実行できませんに注意してください。 クエリを実行する場合。  

- `foreach` (C#) または `For Each` (Visual Basic) ステートメントによって列挙された場合。  
- など、コレクションの操作で列挙される`ToArray`、 `ToDictionary`、または`ToList`します。  
- などの LINQ 演算子`First`または`Any`クエリの最も外側の部分で指定されます。  
- 次のメソッドのいずれかと呼ばれます。`Load`拡張メソッドを`DbEntityEntry.Reload`、 `Database.ExecuteSqlCommand`、および`DbSet<T>.Find`指定のキーを持つエンティティは既にコンテキストに読み込まれている場合は、します。  

## <a name="lifetime"></a>有効期間  

コンテキストの有効期間は、インスタンスが作成され、インスタンスが破棄またはガベージ コレクトされたときに終了を開始します。 使用**を使用して**コンテキストが制御ブロックの最後で破棄するすべてのリソースが必要なかどうか。 使用すると**を使用して**、コンパイラは try/finally ブロックを自動的に作成およびで dispose を呼び出します、**最後に**ブロックします。  

``` csharp
public void UseProducts()
{
    using (var context = new ProductContext())
    {     
        // Perform data access using the context
    }
}
```  

次のコンテキストの有効期間を決定する場合に、一般的なガイドラインを示します。  

- Web アプリケーションを使用する場合は、要求ごとにコンテキスト インスタンスを使用します。  
- Windows Presentation Foundation (WPF) または Windows フォームを使用する場合は、フォームごとコンテキスト インスタンスを使用します。 これにより、変更の追跡機能を使用してそのコンテキストを提供します。  
- コンテキストのインスタンスは、依存関係の注入コンテナーで作成される場合、は、通常、コンテキストを破棄するコンテナーの役割。
- アプリケーション コードでは、コンテキストを作成する場合は、必要でなくなったとき、コンテキストを破棄する注意してください。  
- 実行時間の長いコンテキストを使用する場合は、次を考慮してください。  
    - メモリに複数のオブジェクトとそれらの参照を読み込むと、コンテキストのメモリ使用量は急速に増える可能性があります。 これは、パフォーマンスを低下させる原因になります。  
    - コンテキストがスレッド セーフなしたがってこの属性は複数のスレッドでの作業を同時に実行全体でいない共有する必要があります。
    - 例外は、回復不可能な状態であるコンテキストにより、アプリケーション全体は終了できます。  
    - データの照会時と更新時の時間差が大きくなると、同時実行に関する問題が生じる可能性が高くなります。  

## <a name="connections"></a>接続  

既定では、コンテキストは、データベースへの接続を管理します。 コンテキストが開き、必要に応じて、接続を閉じます。 たとえば、コンテキストはクエリを実行する接続を開き、すべての結果セットが処理されたときに、接続を閉じます。  

接続の開閉をより詳細に制御する必要がある場合もあります。 たとえば、SQL Server Compact を使用する場合、パフォーマンスを向上させるために、アプリケーションの有効期間にわたってデータベースに別の開いている接続を維持するために多くの場合、推奨します。 `Connection` プロパティを使用することにより、手動でこのプロセスを管理できます。  
