---
title: EF4、EF5 と EF6 のパフォーマンスに関する考慮事項
author: divega
ms.date: 10/23/2016
ms.assetid: d6d5a465-6434-45fa-855d-5eb48c61a2ea
ms.openlocfilehash: a58461a6d18d9d53c002b5d45cecbff7b0cdf81e
ms.sourcegitcommit: 2b787009fd5be5627f1189ee396e708cd130e07b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/13/2018
ms.locfileid: "45490260"
---
# <a name="performance-considerations-for-ef-4-5-and-6"></a>EF 4、5、および 6 のパフォーマンスに関する考慮事項
David Obando、Eric Dettinger およびその他のユーザー

公開日: 2012 年 4 月

最終更新日: 2014 年 5 月

------------------------------------------------------------------------

## <a name="1-introduction"></a>1.はじめに

オブジェクト リレーショナル マッピング フレームワークは、オブジェクト指向のアプリケーションでのデータ アクセスの抽象化を提供する便利な方法です。 .NET アプリケーションでは、Microsoft は、O/RM Entity Framework は、お勧めします。 すべての抽象化、パフォーマンスになる可能性が問題になります。

このホワイト ペーパーでは、パフォーマンスに影響する Entity Framework の内部アルゴリズムのアイデアを開発者に提供し、調査のためのヒントを提供する Entity Framework を使用してアプリケーションを開発する際に、パフォーマンスに関する考慮事項を表示するのに書き込まれたとEntity Framework を使用するアプリケーションでのパフォーマンスを向上します。 多くのパフォーマンスに優れたトピック既に、web では、使用可能であれば、これらのリソースを指すしようとしたも。

パフォーマンスは注意が必要です。 このホワイト ペーパーでは、リソースに役立つパフォーマンスを行う Entity Framework を使用するアプリケーションの決定に関連します。 一部のパフォーマンスを示すためにテストのメトリックが含まれていますが、これらのメトリックは、アプリケーションに表示されるパフォーマンスの絶対インジケーターとして意図していません。

実際には、このドキュメントには、Entity Framework 4、.NET 4.0 と Entity Framework 5 で実行され、6 は .NET 4.5 で動作が想定しています。 Entity Framework 5 のパフォーマンスの強化の多くは、.NET 4.5 に付属するコア コンポーネント内に存在します。

Entity Framework 6 は、帯域外リリース、.NET に付属する Entity Framework のコンポーネントに依存しません。 Entity Framework 6 では、.NET 4.0 と .NET 4.5 では、両方で動作し、.NET 4.0 からアップグレードしていないけれども、そのアプリケーション内で Entity Framework の最新の必要なものに大きなパフォーマンス上の利点を提供することができます。 この記事の執筆時に使用可能な最新バージョンを参照場合、このドキュメントでは、Entity Framework 6 をメンション、: バージョン 6.1.0 します。

## <a name="2-cold-vs-warm-query-execution"></a>2.コールド vs します。ウォーム クエリの実行

任意のクエリが特定のモデルに対して行われた最初の時間はバック グラウンドで読み込むし、モデルを検証する作業の多くを Entity Framework。 頻繁にこの最初のクエリと呼ば「コールド」クエリ。  既に読み込まれたモデルに対するクエリをさらには「ウォーム」のクエリと呼ばれ、はるかに速くなります。

Entity Framework を使用してクエリを実行するときに時間を要した箇所の概要と Entity Framework 6 のものを改善する場所を参照してください。

**最初のクエリの実行 – コールド クエリ**

| コードのユーザーの書き込み                                                                                     | アクション                    | EF4 パフォーマンスに与える影響                                                                                                                                                                                                                                                                                                                                                                                                        | EF5 パフォーマンスに与える影響                                                                                                                                                                                                                                                                                                                                                                                                                                                    | EF6 パフォーマンスに与える影響                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | コンテキストの作成          | Medium                                                                                                                                                                                                                                                                                                                                                                                                                        | Medium                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | クエリ式の作成 | Low                                                                                                                                                                                                                                                                                                                                                                                                                           | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var c1 = q1.First();`                                                                             | LINQ クエリの実行      | メタデータの読み込み: キャッシュですが高 <br/> -生成の表示: 可能性のある非常に高いが、キャッシュされました。 <br/> パラメーターの評価: Medium <br/> -クエリの変換: Medium <br/> 実体化の生成: キャッシュされたが、中規模 <br/> -データベース クエリの実行: 可能性のある高 <br/> + Connection.Open <br/> + Command.ExecuteReader <br/> + DataReader.Read <br/> オブジェクトの具体化: Medium <br/> Id 参照: Medium | メタデータの読み込み: キャッシュですが高 <br/> -生成の表示: 可能性のある非常に高いが、キャッシュされました。 <br/> パラメーターを評価します低。 <br/> -変換のクエリ: キャッシュされたが、中規模 <br/> 実体化の生成: キャッシュされたが、中規模 <br/> -データベース クエリの実行: 度の高い (いくつかの状況でのクエリの向上) <br/> + Connection.Open <br/> + Command.ExecuteReader <br/> + DataReader.Read <br/> オブジェクトの具体化: Medium <br/> Id 参照: Medium | メタデータの読み込み: キャッシュですが高 <br/> -生成の表示: キャッシュされたが、中規模 <br/> パラメーターを評価します低。 <br/> -変換のクエリ: キャッシュされたが、中規模 <br/> 実体化の生成: キャッシュされたが、中規模 <br/> -データベース クエリの実行: 度の高い (いくつかの状況でのクエリの向上) <br/> + Connection.Open <br/> + Command.ExecuteReader <br/> + DataReader.Read <br/> オブジェクトの具体化: 中規模 (EF5 よりも高速) <br/> Id 参照: Medium |
| `}`                                                                                                  | Connection.Close          | Low                                                                                                                                                                                                                                                                                                                                                                                                                           | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |


**2 番目のクエリの実行 – ウォーム クエリ**

| コードのユーザーの書き込み                                                                                     | アクション                    | EF4 パフォーマンスに与える影響                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | EF5 パフォーマンスに与える影響                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | EF6 パフォーマンスに与える影響                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | コンテキストの作成          | Medium                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Medium                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | クエリ式の作成 | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var c1 = q1.First();`                                                                             | LINQ クエリの実行      | メタデータ~~読み込み~~参照:~~キャッシュですが高~~低 <br/> -表示~~生成~~参照:~~可能性のある非常に高いが、キャッシュされた~~低 <br/> パラメーターの評価: Medium <br/> -クエリ~~翻訳~~参照: Medium <br/> 実体化~~生成~~参照:~~キャッシュですが中程度~~低 <br/> -データベース クエリの実行: 可能性のある高 <br/> + Connection.Open <br/> + Command.ExecuteReader <br/> + DataReader.Read <br/> オブジェクトの具体化: Medium <br/> Id 参照: Medium | メタデータ~~読み込み~~参照:~~キャッシュですが高~~低 <br/> -表示~~生成~~参照:~~可能性のある非常に高いが、キャッシュされた~~低 <br/> パラメーターを評価します低。 <br/> -クエリ~~翻訳~~参照:~~キャッシュですが中程度~~低 <br/> 実体化~~生成~~参照:~~キャッシュですが中程度~~低 <br/> -データベース クエリの実行: 度の高い (いくつかの状況でのクエリの向上) <br/> + Connection.Open <br/> + Command.ExecuteReader <br/> + DataReader.Read <br/> オブジェクトの具体化: Medium <br/> Id 参照: Medium | メタデータ~~読み込み~~参照:~~キャッシュですが高~~低 <br/> -表示~~生成~~参照:~~キャッシュですが中程度~~低 <br/> パラメーターを評価します低。 <br/> -クエリ~~翻訳~~参照:~~キャッシュですが中程度~~低 <br/> 実体化~~生成~~参照:~~キャッシュですが中程度~~低 <br/> -データベース クエリの実行: 度の高い (いくつかの状況でのクエリの向上) <br/> + Connection.Open <br/> + Command.ExecuteReader <br/> + DataReader.Read <br/> オブジェクトの具体化: 中規模 (EF5 よりも高速) <br/> Id 参照: Medium |
| `}`                                                                                                  | Connection.Close          | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |


ウォームとコールドの両方のクエリのパフォーマンス コストを削減するいくつかの方法し、次のセクションでこれらを見てみましょう。 具体的には、モデル ビューの生成中に発生したパフォーマンスの問題を解消する必要がありますが、事前生成済みのビューを使用してコールド クエリで読み込みのコストの削減について説明します。 ウォーム クエリでは、クエリ プランのキャッシュ、なし、追跡クエリ、および別のクエリ実行オプションについて説明します。

### <a name="21-what-is-view-generation"></a>2.1 ビューの生成をとは

どのようなビューを理解するために生成は、「ビューのマッピング」とはまず理解する必要があります。 マッピング ビューは、各エンティティ セットおよびアソシエーションのマッピングで指定されている変換の実行可能表現です。 内部的には、これらのマッピング ビューは、CQTs (正規のクエリ ツリー) の形状を実行します。 2 種類のマッピング ビューがあります。

-   ビューに対してクエリを: これらは、データベース スキーマから概念モデルに移行するために必要な変換を表します。
-   ビューを更新します。 これらは、概念モデルからデータベース スキーマに移行するために必要な変換を表します。

概念モデルのさまざまな方法でデータベース スキーマが異なる場合があります留意してください。 たとえば、1 つ 1 つのテーブルを使用して、2 つの異なるエンティティ型のデータを格納する可能性があります。 継承と重要なマッピングは、マッピング ビューの複雑さの役割を果たします。

マッピングの仕様に基づいてこれらのビューの計算処理は、ビューの生成と呼ばれるものです。 ビューの生成するかを実行できる動的にモデルが読み込まれるときに、またはビルド時に、「事前に生成されたビュー」; を使用して後者の場合は、c の Entity SQL ステートメントの形式でシリアル化する\#または VB ファイル。

ビューが生成されると、それらも検証されます。 パフォーマンスの観点からは、ビューの生成のコストの大半は、これによって、エンティティ間の接続が合理的なられ、適切なカーディナリティのサポートされているすべての操作があるビューの検証実際にです。

エンティティ セットに対するクエリを実行すると、クエリは、対応するクエリ ビューと結合されますと、この構成の結果がバッキング ストアが理解できるクエリの表現を作成するプランのコンパイラで処理実行します。 SQL Server では、このコンパイルの最終的な結果は、T-SQL の SELECT ステートメントになります。 最初に、エンティティ セットに対する更新が実行されると、同様の手順にターゲット データベースの DML ステートメントに変換する更新プログラム ビューが実行されます。

### <a name="22-factors-that-affect-view-generation-performance"></a>2.2 ビューの生成のパフォーマンスに影響する要因を

ビューの生成のステップのパフォーマンスは、モデルのサイズでどのように相互接続されたモデルにもだけでなく依存します。 2 つのエンティティが継承チェーンまたはアソシエーションを使用して接続している場合は接続されていると言います。 同様に 2 つのテーブルを外部キーを使用して接続している場合は接続されます。 接続されているエンティティと、スキーマ内のテーブルの数を増やすと、ビューの生成、コストが増えます。

生成し、検証のビューを使用しているアルゴリズムはこれを改善するいくつかの最適化を使用して操作を行います最悪の場合、指数。 パフォーマンスが低下すると思われる最大の要因は次のとおりです。

-   エンティティの数とこれらのエンティティ間のアソシエーションの量を参照するモデルのサイズ。
-   モデルの複雑さ、多くの型に関連する継承具体的には。
-   外部キー アソシエーションではなく独立アソシエーションでを使用します。

小規模で単純なモデル、コストが事前生成済みのビューを使用することはありませんに十分小さい可能性があります。 モデルのサイズと複雑さの増加、ビューの生成と検証のコストを削減する使用可能ないくつかのオプションがあります。

### <a name="23-using-pre-generated-views-to-decrease-model-load-time"></a>2.3 モデルを小さく Pre-Generated ビューを使用して読み込み時間

#### <a name="231-pre-generated-views-using-the-entity-framework-power-tools"></a>2.3.1 Entity Framework Power Tools を使用して事前生成されたビュー

Entity Framework Power Tools を使用して、モデルのクラス ファイルを右クリックし、「ビューの生成」を選択する Entity Framework メニューを使用して EDMX と Code First モデルのビューを生成することも検討できます。 Entity Framework Power Tools が DbContext 派生コンテキストでのみ動作しをご覧ください\<http://visualstudiogallery.msdn.microsoft.com/72a60b14-1581-4b9b-89f2-846072eff19d>します。

Entity Framework 6 で事前生成済みのビューを使用する方法の詳細についてを参照してください。 [Pre-Generated マッピング ビュー](~/ef6/fundamentals/performance/pre-generated-views.md)します。

#### <a name="232-how-to-use-pre-generated-views-with-a-model-created-by-edmgen"></a>2.3.2 EDMGen によって作成されたモデルで事前に生成したビューを使用する方法

EDMGen は、.NET に付属し、機能が Entity Framework 4 および 5、Entity Framework 6 ではなくユーティリティです。 EDMGen を使用して、コマンドラインから、モデル ファイルをオブジェクト レイヤー、およびビューを生成できます。 VB または C の任意の言語でビュー ファイルである出力の 1 つは\#します。 これは、各エンティティ セットの Entity SQL スニペットを含むコード ファイルです。 事前生成済みのビューを有効にするのには、プロジェクトでファイルをインクルードだけです。

モデルのスキーマ ファイルに手動で編集を作成する場合は、ビュー ファイルを再生成する必要があります。 EDMGen を使用してこれを行う、 **/mode:ViewGeneration**フラグ。

さらに参照は、次を参照してください。[方法: クエリ パフォーマンスを向上させる Pre-Generate ビュー](https://msdn.microsoft.com/library/bb896240.aspx)します。

#### <a name="233-how-to-use-pre-generated-views-with-an-edmx-file"></a>2.3.3 EDMX ファイルを Pre-Generated ビューを使用する方法

EDMX ファイルのビューを生成する EDMGen を使用することもできます。 - 前述の MSDN トピックでは、- これを行うビルド前イベントを追加する方法を説明しますが、これは、複雑なとことができない場合がします。 通常、モデルが edmx ファイルの場合、ビューを生成する T4 テンプレートを使用する方が簡単になります。

ADO.NET チームのブログが投稿をビューの生成に T4 テンプレートを使用する方法について説明します ( \<http://blogs.msdn.com/b/adonet/archive/2008/06/20/how-to-use-a-t4-template-for-view-generation.aspx>)します。 この投稿には、ダウンロードしてプロジェクトに追加できるテンプレートが用意されています。 テンプレートは、Entity Framework の最新バージョンで動作する保証はありませんが、Entity Framework の最初のバージョンとして記述されました。 ただし、ダウンロードできますビュー生成テンプレートの最新セット Entity Framework 4 と 5from、Visual Studio ギャラリー。

-   VB.NET の場合: \<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d>
-   C\#: \<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d>

Entity Framework 6 を使用している場合は、ビューを取得できます、生成 T4 テンプレートで Visual Studio ギャラリーから\<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>します。

#### <a name="234-how-to-use-pre-generated-views-with-a-code-first-model"></a>2.3.4 Code First モデルを Pre-Generated ビューを使用する方法

コードの最初のプロジェクトで事前に生成したビューを使用することもできます。 Entity Framework Power Tools では、コードの最初のプロジェクト ビュー ファイルを生成する機能があります。 Visual Studio ギャラリーで、Entity Framework Power Tools が見つかります\<http://visualstudiogallery.msdn.microsoft.com/72a60b14-1581-4b9b-89f2-846072eff19d/>します。

### <a name="24-reducing-the-cost-of-view-generation"></a>2.4 ビューの生成のコストを削減します。

事前生成済みのビューを使用したコンパイル時にモデルの読み込み (実行時) からビューの生成のコストを移動します。 これにより、実行時に起動時のパフォーマンスが向上、中に開発する際にビューの生成の問題点を引き続き発生するされます。 ビューの生成、コンパイル時と実行時の両方のコストを削減するのに役立ついくつかの追加テクニックがあります。

#### <a name="241-using-foreign-key-associations-to-reduce-view-generation-cost"></a>2.4.1 を外部キー アソシエーションを使用してビューの生成のコストを削減するには

さまざまな場合において、ビューの生成に費やされた時間を改善する独立アソシエーションからモデルを外部キー アソシエーションで関連付けを大幅に切り替えきました。

この機能強化の例として、EDMGen を使用して Navision モデルの 2 つのバージョンを生成します。 *注: seeappendix Cfor Navision モデルの説明。* Navision モデルは、非常に大きなエンティティとそれらの間のリレーションシップの原因には、この演習では興味深いです。

この非常に大規模なモデルの 1 つのバージョンは、外部キー アソシエーションで生成され、独立アソシエーションで生成された他のです。 各モデルのビューを生成するにかかる所要時間をタイムアウトしました。 エンティティ Framework5 テストでは、Entity Framework 6 のテスト クラス StorageMappingItemCollection から GenerateViews() メソッドを使用するときに、ビューを生成するのにクラス EntityViewGenerator から GenerateViews() メソッドを使用します。 これにより、Entity Framework 6 のコードベースで発生したコードの再構築します。

Entity Framework 5 を使用して、外部キーを持つモデルのビューの生成は、ラボのコンピューターで 65 分をかかりました。 不明などのくらいの時間がかかりましたが、独立アソシエーションを使用するモデルのビューを生成します。 テストの月次の更新プログラムをインストールするラボで、コンピューターが再起動された前に、1 か月間実行されているままです。

Entity Framework 6 を使用して、外部キーを持つモデルのビューの生成は、同じマシンで、28 秒をかかりました。 独立アソシエーションを使用するモデルのビューの生成は、58 秒かかりました。 そのビューの生成コードに Entity Framework 6 を改善という意味では多くのプロジェクトがスタートアップ時間の短縮を取得する事前生成済みのビューを必要はありません。

EDMGen または Entity Framework Power Tools で生成前のビューでは、Entity Framework 4 および 5 を実行できる注釈に重要です。 Entity Framework 6 の表示、Entity Framework Power Tools を使用して、または」の説明に従ってプログラムで生成は実行できます[Pre-Generated マッピング ビュー](~/ef6/fundamentals/performance/pre-generated-views.md)します。

##### <a name="2411-how-to-use-foreign-keys-instead-of-independent-associations"></a>2.4.1.1 独立アソシエーションではなく、外部キーを使用する方法

EDMGen またはエンティティ デザイナーを使用して、Visual Studio で、既定では、Fk を表示し、Fk と IAs を切り替える、1 つのチェック ボックスまたはコマンド ライン フラグしかかかりません。

独立アソシエーションを使用して大規模な Code First モデルがある場合と、ビューの生成に同じ効果があります。 一部の開発者はこれと、そのオブジェクト モデルを汚染するを考慮する場合、依存オブジェクトのクラスの外部キー プロパティを含めることによってこの影響を回避できます。 この件に関する詳細は見つかります\<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>します。

| 使用する場合      | 方法                                                                                                                                                                                                                                                                                                                              |
|:----------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| エンティティ デザイナー | 2 つのエンティティ間の関連付けを追加すると、参照に関する制約があることを確認します。 参照に関する制約は、独立アソシエーションではなく、外部キーを使用する Entity Framework を伝えます。 追加の詳細をご覧ください\<http://blogs.msdn.com/b/efdesign/archive/2009/03/16/foreign-keys-in-the-entity-framework.aspx>します。 |
| EDMGen          | EDMGen を使用して、データベースから、ファイルを生成する、外部キーが適用されるため、そのため、モデルに追加します。 EDMGen によって公開されるさまざまなオプションの詳細については、次を参照してください。 [ http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx)します。                           |
| Code First      | 「リレーションシップの規則」セクションを参照してください、[コードの最初の規則](~/ef6/modeling/code-first/conventions/built-in.md)Code First を使用する場合は、依存オブジェクトで外部キー プロパティを組み込む方法については、トピック。                                                                                              |

#### <a name="242-moving-your-model-to-a-separate-assembly"></a>2.4.2、モデルを別のアセンブリに移動します。

アプリケーションのプロジェクトに直接、モデルが含まれているし、ビルド前イベントまたは、T4 テンプレートを使ってビューを生成する、ビューの生成と検証は行わ、プロジェクトをリビルドするたびに、モデルが変更されていない場合でも。 モデルを別のアセンブリに移動して、アプリケーションのプロジェクトから参照するの変更を行うアプリケーションにモデルを含むプロジェクトをリビルドする必要はありません。

*注:* クライアント プロジェクトのアプリケーション構成ファイルに、モデルの接続文字列をコピーするを区切るためにモデルを移動するときにアセンブリに注意してください。

#### <a name="243-disable-validation-of-an-edmx-based-model"></a>2.4.3 edmx ベース モデルの検証を無効にします。

EDMX モデルは、モデルが変更されていない場合でも、コンパイル時に検証されます。 モデルは既に検証されている場合は、[プロパティ] ウィンドウで、「ビルドの検証」プロパティを false に設定によってコンパイル時に検証を抑制できます。 モデル、マッピングを変更するときに有効にできます一時的に再検証、変更を確認します。

パフォーマンスの向上に加え、Entity Framework デザイナーの Entity Framework 6 では、「検証でビルド」のコストは、デザイナーの以前のバージョンよりはるかに小さいことに注意してください。

## <a name="3-caching-in-the-entity-framework"></a>Entity Framework で 3 つのキャッシュ

Entity Framework では、キャッシュの組み込みの次の形式があります。

1.  オブジェクト キャッシュ – ObjectContext インスタンスに組み込まれている、ObjectStateManager がそのインスタンスを使用して取得されたオブジェクトのメモリ内で追跡します。 これは、最初のレベルのキャッシュとも呼ばれます。
2.  クエリ プラン キャッシュのクエリが複数回実行されたときに生成されるストア コマンドを再利用します。
3.  メタデータ キャッシュ - 同じモデルに異なる接続で、モデルのメタデータを共有します。

だけでなく、ADO.NET データ プロバイダーのラップ プロバイダーを使用して、データベースから取得された結果のキャッシュを使用して Entity Framework を拡張することもできますと呼ばれる特殊なボックスで、EF が提供されているキャッシュは、2 番目のレベルのキャッシュと呼ばれるもします。

### <a name="31-object-caching"></a>3.1 オブジェクトのキャッシュ

既定でエンティティが、クエリの結果で返されるときに、EF が実体化する前に、ObjectContext は確認、ObjectStateManager に同じキーを持つエンティティが既に読み込まれたします。 同じキーを持つエンティティが既に存在する場合 EF が含まれますが、クエリの結果で。 EF はデータベースに対してクエリを発行しても、この動作は、エンティティを複数回に実体化のコストの多くをバイパスできます。

#### <a name="311-getting-entities-from-the-object-cache-using-dbcontext-find"></a>3.1.1 DbContext の検索を使用して、オブジェクト キャッシュからエンティティを取得します。

標準のクエリとは異なり DbSet (EF 4.1 で最初に含まれている Api) の Find メソッドは検索を実行メモリ内でも、データベースに対してクエリを発行する前にします。 2 つの異なる ObjectContext インスタンスが個別のオブジェクトのキャッシュがあることを意味する、2 つの異なる ObjectStateManager インスタンスをあることに注意する重要です。

検索では、主キーの値を使用して、そのコンテキストによって追跡されるエンティティを検索しようとしています。 コンテキストにエンティティがない場合、クエリの実行、および、データベースに対して評価方法と、コンテキストまたはデータベース内にエンティティが見つからない場合、null が返されます。 検索にも、コンテキストに追加されているが、データベースに保存されていないエンティティが返されますことに注意してください。

検索を使用する場合にパフォーマンスに関する考慮事項があります。 既定では、このメソッドを呼び出し、データベースにコミット保留中の変更を検出するために、オブジェクト キャッシュの検証がトリガーされます。 このプロセスは非常に多数のオブジェクト キャッシュ内、または、オブジェクト キャッシュに追加される大きなオブジェクト グラフ内のオブジェクトがある場合に非常に安価にできますも無効にできます。 場合によっては、することに気付くかもしれません自動を無効にすると、メソッドを検出する検索を呼び出すことの違いの桁に変更します。 まだいる際にオブジェクト実際には、キャッシュと、オブジェクトがあるデータベースから取得する際に、第 2 桁が認識します。 5000 エンティティの負荷がかかっている、ミリ秒単位で、当社 microbenchmarks の一部を使用して取得された測定値と、グラフの例を次に示します。

![.NET 4.5 の対数スケール](~/ef6/media/net45logscale.png ".NET 4.5 - 対数スケール")

自動検出の変更を無効になっていると検索の例:

``` csharp
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    context.Configuration.AutoDetectChangesEnabled = true;
    ...
```

Find メソッドを使用するときに考慮する必要があることです。

1.  オブジェクトがキャッシュにない場合は、検索の利点が否定しますが、構文がキーで、クエリよりも簡単です。
2.  自動の変更を検出する場合は、有効になっている Find メソッドのコストが 1 桁、または、モデルと、オブジェクト キャッシュ内のエンティティの量の複雑さに応じて、さらに増やすことができます。

また、のみを見つけることに注意してが探しているエンティティを返すは自動的に読み込み、関連付けられているエンティティが既にキャッシュにない、オブジェクトの場合。 関連付けられているエンティティを取得する必要がある場合は、一括読み込みでのキーによって、クエリを使用できます。 詳細については、次を参照してください。 **8.1 Lazy Loading とします。一括読み込み**します。

#### <a name="312-performance-issues-when-the-object-cache-has-many-entities"></a>3.1.2 パフォーマンスの問題をオブジェクト キャッシュに多数のエンティティがある場合

オブジェクト キャッシュは、Entity Framework の全体的な応答性の向上に役立ちます。 ただし、オブジェクト キャッシュが非常に大量のエンティティの追加などの特定の操作に影響を与える読み込まれた場合は、削除、エントリ、SaveChanges を検索します。 具体的には、DetectChanges への呼び出しをトリガーする操作は非常に大きいオブジェクトのキャッシュによって悪影響を及ぼす影響します。 DetectChanges は、オブジェクト状態マネージャーと、オブジェクト グラフのサイズを直接判断のパフォーマンスは、オブジェクト グラフを同期します。 DetectChanges の詳細については、次を参照してください。 [POCO エンティティでの変更を追跡](https://msdn.microsoft.com/library/dd456848.aspx)します。

Entity Framework 6 を使用して、開発者はコレクションの反復処理し、インスタンスにつき 1 回追加を呼び出すのではなく、DbSet に直接 AddRange と RemoveRange を呼び出すことができません。 Range メソッドを使用する利点は、DetectChanges のコストは、追加された各エンティティごとに 1 回ではなくエンティティのセット全体の 1 回有料のみです。

### <a name="32-query-plan-caching"></a>3.2 はクエリ プランのキャッシュ

初めてクエリを実行すると、それはストア コマンド (たとえば、T-SQL が SQL Server に対して実行するときに実行されます) に概念のクエリを変換するプランを内部コンパイラ説明します。  ストアが実行されるクエリ プランのキャッシュが有効になっている場合、クエリは、[次へ] にコマンドは、プランのコンパイラをバイパスして、実行するためのクエリ プラン キャッシュから直接取得されます。

クエリ プランのキャッシュは、同じ AppDomain 内で ObjectContext インスタンス間で共有されます。 クエリ プランのキャッシュのメリットを ObjectContext インスタンスを保持する必要はありません。

#### <a name="321-some-notes-about-query-plan-caching"></a>3.2.1 クエリ プランのキャッシュについての注意事項

-   すべてのクエリの種類のクエリ プランのキャッシュが共有: Entity SQL、LINQ to Entities と CompiledQuery オブジェクト。
-   既定では、クエリ プランのキャッシュが有効になっている Entity SQL クエリでは、ObjectQuery EntityCommand を使用またはを実行するかどうか。 これも既定で有効に linq to Entities クエリでは、.NET 4.5 では、Entity Framework と Entity Framework 6
    -   (EntityCommand ObjectQuery 上) EnablePlanCaching プロパティを false に設定して、クエリ プランのキャッシュを無効にすることができます。 例えば:
``` csharp
                    var query = from customer in context.Customer
                                where customer.CustomerId == id
                                select new
                                {
                                    customer.CustomerId,
                                    customer.Name
                                };
                    ObjectQuery oQuery = query as ObjectQuery;
                    oQuery.EnablePlanCaching = false;
```
-   パラメーター化されたクエリでは、パラメーターの値を変更する、まだヒット、キャッシュされたクエリ。 パラメーターのファセット (たとえば、サイズ、有効桁数、またはスケール) を変更すると、キャッシュ内の異なるエントリがヒットします。
-   Entity SQL を使用する場合、クエリ文字列は、キーの一部です。 クエリが機能的に同等場合でも、クエリのすべての変更が、別のキャッシュ エントリで発生します。 これには、大文字小文字の区別、または空白文字への変更が含まれます。
-   LINQ を使用する場合は、キーの一部を生成するクエリが処理されます。 LINQ 式を変更すると、そのため、別のキーが生成されます。
-   他の技術的な制限が適用可能性があります。詳細については、Autocompiled クエリを参照してください。

#### <a name="322------cache-eviction-algorithm"></a>3.2.2 キャッシュ削除アルゴリズム

内部アルゴリズムの動作がヘルプを有効または無効にするクエリ プランのキャッシュを解明する方法について理解します。 クリーンアップ アルゴリズムは次のとおりです。

1.  キャッシュに設定された数のエントリ (800) が含まれているを定期的に (1 回数/分) キャッシュからフラッシュされるタイマーが開始します。
2.  キャッシュのスイープ中に、エントリが LFRU (最も頻繁に – 最近使用した) 上のキャッシュから削除されます単位。 このアルゴリズムは両方のヒット カウントと年齢考慮エントリを取り出すを決定する際にします。
3.  キャッシュには各キャッシュのスイープの末尾には、800 のエントリにはもう一度が含まれています。

すべてのキャッシュ エントリは削除するエントリを決定する際に均等に扱われます。 これを CompiledQuery のストア コマンドが同じ確率として Entity SQL クエリのストア コマンドの削除のことを意味します。

キャッシュに 800 エンティティがあるが、このタイマーが開始した後、60 秒間はキャッシュのスイープを行うとき、キャッシュの削除タイマーが開始に注意してください。 つまり、最大で 60 秒間、キャッシュは非常に大きくなるになることがあります。

#### <a name="323-------test-metrics-demonstrating-query-plan-caching-performance"></a>3.2.3 メトリックが示すクエリ プランのキャッシュのパフォーマンスをテストします。

クエリ プランが、アプリケーションのパフォーマンス上のキャッシュの効果を示すためにテストを実行数 Navision モデルに対する Entity SQL クエリを実行します。 Navision モデルと実行されたクエリの種類の説明については、付録を参照してください。 このテストで最初のクエリのリストを反復処理し、(キャッシュが有効になっている) 場合は、キャッシュに追加する 1 つずつを 1 回実行します。 この手順は一定ではありません。 スイープを実行します。 キャッシュを許可するのには 60 秒以上のメイン スレッドをスリープ状態次に、最後に、キャッシュされたクエリを実行するリストの 2 つ目を時間の経過に反復処理します。 さらに、時間を正確に取得したクエリ プランのキャッシュで指定された特典を反映するように、クエリの各セットが実行される前に、SQL Server プラン キャッシュがフラッシュされます。

##### <a name="3231-------test-results"></a>3.2.3.1 テスト結果

| テスト                                                                   | EF5 キャッシュなし | EF5 キャッシュ | EF6 キャッシュなし | EF6 のキャッシュ |
|:-----------------------------------------------------------------------|:-------------|:-----------|:-------------|:-----------|
| 18723 のすべてのクエリを列挙します。                                          | 124          | 125.4      | 124.3        | 125.3      |
| スイープ (800 最初のクエリについて、複雑さに関係なく) を回避します。  | 41.7         | 5.5        | 40.5         | 5.4        |
| AggregatingSubtotals クエリ (178 合計 - スイープが避けられます) | 39.5         | 4.5        | 38.1         | 4.6        |

*すべての時刻の秒数。*

精神的の多くを実行するときに (たとえば、クエリを動的に作成された)、個別のクエリのキャッシュ問題が解決しないし、キャッシュの結果として得られるフラッシュすると、実際にこれを使用してからプランのキャッシュを最大限に効果的なクエリを保つことができます。

AggregatingSubtotals クエリでは、最も複雑なクエリをテストしました。 予想どおり、クエリが複雑で利点から、クエリ プランのキャッシュが表示されます。

CompiledQuery が本当にそのプランがキャッシュでの LINQ クエリであるため、CompiledQuery 同等の Entity SQL クエリとの比較は、同様の結果が必要です。 実際には、アプリに大量の動的な Entity SQL クエリがある場合は、クエリでキャッシュがいっぱいも事実上により CompiledQueries「逆コンパイル」がキャッシュからフラッシュされるときにします。 このシナリオで、CompiledQueries の優先順位を動的クエリでキャッシュを無効にするとパフォーマンスが向上する可能性があります。 さらに、もちろん、書き直すことをアプリにパラメーター化クエリを使用して動的クエリではなく。

### <a name="33-using-compiledquery-to-improve-performance-with-linq-queries"></a>3.3 CompiledQuery を使用して LINQ クエリのパフォーマンスを向上させる

テストの結果を示すこと CompiledQuery を使用して実行できる 7% の特典 autocompiled 経由で LINQ クエリです。つまり、7%、Entity Framework スタックからコードを実行する時間を費やすしますアプリケーションは 7% 高速になることは限りません。 一般に、作成と EF 5.0 CompiledQuery オブジェクトの保守のコストは価値のメリットと比較した場合、ここで問題が発生可能性がありますできません。 走行距離は異なる可能性があります、ため、プロジェクトに追加のプッシュが必要な場合にこのオプションを実行します。 CompiledQueries は ObjectContext から派生したモデルと互換性があり、DbContext 派生モデルと互換性がない、のみことに注意してください。

作成して、CompiledQuery を呼び出すことの詳細については、次を参照してください。[コンパイルされたクエリ (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx)します。

2 つの考慮事項が CompiledQuery、つまり、使用するという要件静的インスタンスと、問題と構成可能性があるを使用する場合に実行する必要があります。 詳細については、これら 2 つの考慮事項を次に示します。

#### <a name="331-------use-static-compiledquery-instances"></a>3.3.1 CompiledQuery の静的インスタンスを使用します。

これを行うたびに、データベースからデータをフェッチする必要があるように時間のかかるプロセスは、LINQ クエリをコンパイル、ので。 CompiledQuery インスタンスでは、1 回コンパイルして、複数回実行することができますが、注意が必要し調達を何度もコンパイルではなく、毎回同じ CompiledQuery インスタンスを再利用します。 CompiledQuery インスタンスを格納する静的メンバーの使用が必要になります。それ以外の場合、上の利点は表示されません。

たとえば、ページが選択したカテゴリの製品の表示を処理するために次のメソッドの本体とします。

``` csharp
    // Warning: this is the wrong way of using CompiledQuery
    using (NorthwindEntities context = new NorthwindEntities())
    {
        string selectedCategory = this.categoriesList.SelectedValue;

        var productsForCategory = CompiledQuery.Compile<NorthwindEntities, string, IQueryable<Product>>(
            (NorthwindEntities nwnd, string category) =>
                nwnd.Products.Where(p => p.Category.CategoryName == category)
        );

        this.productsGrid.DataSource = productsForCategory.Invoke(context, selectedCategory).ToList();
        this.productsGrid.DataBind();
    }

    this.productsGrid.Visible = true;
```

ここでは、メソッドが呼び出されるたびに、実行時に新しい CompiledQuery インスタンスを作成するは。 クエリのプラン キャッシュからのストア コマンドを取得することによってパフォーマンス上の利点を確認するのではなくは新しいインスタンスが作成されるたびに、CompiledQuery はプラン コンパイラを移動します。 実際には、するが汚染 CompiledQuery の新しいエントリで、クエリ プランのキャッシュ、メソッドが呼び出されるたびにします。

代わりに、メソッドが呼び出されるたびに、同じコンパイル済みクエリを呼び出すために、コンパイル済みのクエリの静的インスタンスを作成します。 1 つの方法にこれは、オブジェクト コンテキストのメンバーとして追加すると、CompiledQuery インスタンス。  行うことができますし、モ ノほとんど明確になり、CompiledQuery にアクセスするヘルパー メソッドを使用しています。

``` csharp
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IEnumerable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
            );

        public IEnumerable<Product> GetProductsForCategory(string categoryName)
        {
            return productsForCategoryCQ.Invoke(this, categoryName).ToList();
        }
```

このヘルパー メソッドには、次のように呼び出されます。

``` csharp
    this.productsGrid.DataSource = context.GetProductsForCategory(selectedCategory);
```

#### <a name="332-------composing-over-a-compiledquery"></a>3.3.2 を CompiledQuery 経由で作成します。

任意の LINQ クエリを作成する機能は非常に便利です。これを行うには、単にメソッドを呼び出す対象の IQueryable 後など*Skip()* または*Count()* します。 ただし、これは基本的には、新しい IQueryable オブジェクトを返します。 CompiledQuery 経由での作成から技術的には停止するにはありませんが、新しい IQueryable オブジェクトの生成は原因はプラン コンパイラを通るをもう一度必要です。

一部のコンポーネントとの構成済みの IQueryable を使用して、高度な機能を有効にするオブジェクト。 たとえば、ASP です。NET の GridView データ バインドできます IQueryable オブジェクトに SelectMethod プロパティを使用しています。 並べ替えとデータ モデルに対するページングを許可するには、この IQueryable オブジェクトは、GridView を作成します。 、ご覧のとおり、CompiledQuery を GridView を使用してコンパイル済みのクエリは達しないが新しい autocompiled クエリが生成します。

Customer Advisory Team はこれで、「潜在的なパフォーマンスの問題でコンパイルされた LINQ クエリ再コンパイル」ブログの投稿について説明します。<http://blogs.msdn.com/b/appfabriccat/archive/2010/08/06/potential-performance-issues-with-compiled-linq-query-re-compiles.aspx>します。

これを実行することがあります 1 つの場所は、プログレッシブのフィルターをクエリに追加する場合です。 たとえば、省略可能なフィルター (たとえば、国と OrdersCount) のいくつかのドロップダウン リストで、[顧客] ページがあるとします。 これらのフィルターを作成するには、CompiledQuery の IQueryable 結果に対するが発生で、新しいクエリを実行するたびに、プランのコンパイラを通過します。

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployee();

        if (this.orderCountFilterList.SelectedItem.Value != defaultFilterText)
        {
            int orderCount = int.Parse(orderCountFilterList.SelectedValue);
            myCustomers = myCustomers.Where(c => c.Orders.Count > orderCount);
        }

        if (this.countryFilterList.SelectedItem.Value != defaultFilterText)
        {
            myCustomers = myCustomers.Where(c => c.Address.Country == countryFilterList.SelectedValue);
        }

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 この再コンパイルを避けるためには、可能なフィルターを考慮に入れてに CompiledQuery を書き直すことができます。

``` csharp
    private static readonly Func<NorthwindEntities, int, int?, string, IQueryable<Customer>> customersForEmployeeWithFiltersCQ = CompiledQuery.Compile(
        (NorthwindEntities context, int empId, int? countFilter, string countryFilter) =>
            context.Customers.Where(c => c.Orders.Any(o => o.EmployeeID == empId))
            .Where(c => countFilter.HasValue == false || c.Orders.Count > countFilter)
            .Where(c => countryFilter == null || c.Address.Country == countryFilter)
        );
```

などの UI でが呼び出されます。

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        int? countFilter = (this.orderCountFilterList.SelectedIndex == 0) ?
            (int?)null :
            int.Parse(this.orderCountFilterList.SelectedValue);

        string countryFilter = (this.countryFilterList.SelectedIndex == 0) ?
            null :
            this.countryFilterList.SelectedValue;

        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployeeWithFilters(
                countFilter, countryFilter);

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 ここでのトレードオフがある、生成されるストア コマンドは、null チェックでフィルターを常にこれらを最適化するには、データベース サーバーの非常に単純にする必要があります。

``` SQL
...
WHERE ((0 = (CASE WHEN (@p__linq__1 IS NOT NULL) THEN cast(1 as bit) WHEN (@p__linq__1 IS NULL) THEN cast(0 as bit) END)) OR ([Project3].[C2] > @p__linq__2)) AND (@p__linq__3 IS NULL OR [Project3].[Country] = @p__linq__4)
```

### <a name="34-metadata-caching"></a>3.4 メタデータのキャッシュ

Entity Framework では、メタデータのキャッシュもサポートしています。 同じモデルに異なる接続間で型情報とデータベースへの型マッピング情報のキャッシュこれは基本的にします。 メタデータ キャッシュは、AppDomain ごとに一意です。

#### <a name="341-metadata-caching-algorithm"></a>3.4.1 メタデータ キャッシュ アルゴリズム

1.  モデルのメタデータ情報は、各 EntityConnection の ItemCollection に格納されます。
    -   なお、別の ItemCollection オブジェクト モデルのさまざまな部分があります。 たとえば、StoreItemCollections には、データベース モデルに関する情報が含まれます。ObjectItemCollection には、データ モデルに関する情報が含まれています。EdmItemCollection には、概念モデルに関する情報が含まれています。

2.  2 つの接続は、同じ接続文字列を使用して、同じ ItemCollection インスタンスが共有されます。
3.  機能的に同等ですが、異なるテキスト上の接続文字列は、さまざまなメタデータ キャッシュがあります。 共有メタデータが発生する必要があります、トークンの順序を変更するだけ、接続文字列をトークン化操作を行います。 機能的に同じに見える 2 つの接続文字列可能性がありますいない評価と同じトークン化の後にします。
4.  ItemCollection を使用して定期的にチェックします。 あるワークスペースが最近アクセスされませんがされていると判断された場合は、[次へ] のキャッシュのスイープのクリーンアップのマークされます。
5.  EntityConnection を作成するだけで、(ただし、接続が開かれるまで、項目のコレクションは初期化されません) を作成するメタデータ キャッシュが発生します。 キャッシュ アルゴリズムは、"使用"でないを判断するまでは、このワークスペースをメモリ内に残ります。

Customer Advisory Team ブログの投稿、ItemCollection への参照を保持する大規模なモデルを使用する場合は、「廃止」を回避するために説明を執筆しています: \<http://blogs.msdn.com/b/appfabriccat/archive/2010/10/22/metadataworkspace-reference-in-wcf-services.aspx>します。

#### <a name="342-the-relationship-between-metadata-caching-and-query-plan-caching"></a>3.4.2 メタデータのキャッシュと、クエリ プランのキャッシュ間のリレーションシップ

クエリ プランのキャッシュ インスタンスは、ストアの種類の MetadataWorkspace の ItemCollection に住んでいます。 これは、特定の MetadataWorkspace を使用してインスタンス化された任意のコンテキストに対するクエリのストアのキャッシュされたコマンドが使用されることを意味します。 若干異なりますが、トークン化した後は一致しない 2 つの接続文字列があれば、別のクエリ プランのキャッシュ インスタンスを必要があることを意味します。

### <a name="35-results-caching"></a>3.5 結果のキャッシュ

結果のキャッシュ (とも呼ばれます「第 2 レベルのキャッシュ」) がローカル キャッシュ内でのクエリの結果を保持します。 クエリを発行するときに初めて表示かどうか、結果は、ストアに対してクエリする前にローカルで使用できます。 結果のキャッシュは、Entity Framework によって直接サポートされていない、折り返しプロバイダーを使用して 2 番目のレベルのキャッシュを追加すること勧めします。 2 番目のレベルのキャッシュを使用してラップ プロバイダーの例は、Alachisoft の[NCache に基づいてエンティティ フレームワークの第 2 レベルのキャッシュ](http://www.alachisoft.com/ncache/entity-framework.html)します。

この 2 番目のレベルのキャッシュの実装は、挿入された機能を LINQ 式が評価された後の場所 (と funcletized) を受け取ると、クエリ実行プランを計算または最初のレベルのキャッシュから取得します。 具体化パイプラインは後で実行されるため、第 2 レベルのキャッシュは生のデータベースの結果のみを格納します。

#### <a name="351-additional-references-for-results-caching-with-the-wrapping-provider"></a>3.5.1 結果の折り返しのプロバイダーでのキャッシュのその他の参照

-   Julie Lerman には、Windows Server AppFabric のキャッシュを使用するサンプルの折り返しのプロバイダーを更新する方法を含む"2 番目のレベルのキャッシュで Entity Framework と Windows Azure"MSDN の記事が書き込まれます。 [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)
-   チームのブログに Entity Framework 5 のキャッシュ プロバイダーを実行しているものを取得する方法を説明する投稿が Entity Framework 5 を使用する場合: \<http://blogs.msdn.com/b/adonet/archive/2010/09/13/ef-caching-with-jarek-kowalski-s-provider.aspx>します。 プロジェクトには、第 2 レベルのキャッシュの追加を自動化するために T4 テンプレートも含まれています。

## <a name="4-autocompiled-queries"></a>4 つの Autocompiled クエリ

Entity Framework を使用してデータベースに対してクエリが発行されるときに実際には、結果を具体化する前に、一連の手順を移動する必要があります。このような 1 つの手順では、クエリのコンパイルです。 Entity SQL クエリは、パフォーマンスが向上は自動的にキャッシュとして 2 番目または 3 番目の時間計画コンパイラをスキップし、キャッシュされたプランを使用して、代わりに、同じクエリを実行するように呼ばれていました。

Entity Framework 5 では、自動キャッシュの LINQ to Entities クエリにも導入されました。 作成を高速化の CompiledQuery Entity Framework の過去のエディションで、パフォーマンスが一般的に、こうと、LINQ to Entities クエリ キャッシュされます。 キャッシュは今すぐ自動的には、CompiledQuery を使用せず、ためにを呼び出してこの機能「autocompiled クエリ」します。 クエリ プランのキャッシュとそのしくみの詳細については、クエリ プランのキャッシュを参照してください。

クエリは、再コンパイルする必要がある場合、entity Framework が検出された場合でも、前にコンパイルされている必要があるが、クエリが呼び出されるようにするとします。 再コンパイルするクエリが発生する一般的な条件は次のとおりです。

-   クエリに関連付けられている MergeOption を変更します。 キャッシュされたクエリは使用されませんプラン コンパイラが再び実行、代わりに、新しく作成されたプランがキャッシュを取得します。
-   ContextOptions.UseCSharpNullComparisonBehavior の値を変更します。 MergeOption を変更すると同じ効果が表示されます。

その他の条件によって防止、クエリがキャッシュを使用できます。 一般的な例は次のとおりです。

-   IEnumerable を使用して&lt;T&gt;します。含む&lt;&gt;(T 値)。
-   定数を使用してクエリを生成する関数を使用します。
-   マップされていないオブジェクトのプロパティを使用します。
-   クエリを再コンパイルを必要とする別のクエリにリンクしています。

### <a name="41-using-ienumerablelttgtcontainslttgtt-value"></a>4.1 は IEnumerable を使用して&lt;T&gt;します。含む&lt;T&gt;(T 値)

Entity Framework は、IEnumerable を呼び出すクエリをキャッシュしません&lt;T&gt;します。含む&lt;T&gt;(T 値) に対するメモリ内コレクション、コレクションの値が揮発性と見なされるためです。 プラン コンパイラは常に処理するため、次のクエリはキャッシュされません。

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var query = context.MyEntities
                    .Where(entity => ids.Contains(entity.Id));

    var results = query.ToList();
    ...
}
```

クエリがコンパイル速度または低速方法を決定するに対してどの値を含む IEnumerable のサイズが実行されるに注意してください。 上記の例のような大規模なコレクションを使用する場合、パフォーマンスが大幅に低下することができます。

Entity Framework 6 には、IEnumerable の方法は、最適化が含まれています。&lt;T&gt;します。含む&lt;T&gt;(T 値) は、クエリが実行されたときに機能します。 生成された SQL コードが生成するために高速化と読みやすくし、ほとんどの場合でも速く実行サーバーにします。

### <a name="42-using-functions-that-produce-queries-with-constants"></a>4.2 は、定数を使用してクエリを生成する関数を使用します。

Skip()、利用、Contains() および DefautIfEmpty() LINQ 演算子では、パラメーターを含む SQL クエリを作成しませんが、代わりに、定数として渡された値を格納します。 このため、可能性のあるそれ以外の場合、クエリを汚染最終的に同じクエリはプランでは、EF のスタックと、データベース サーバーの両方をキャッシュ、およびは reutilized 後続のクエリ実行で同じ定数を使用しない限り取得されません。 例えば:

``` csharp
var id = 10;
...
using (var context = new MyContext())
{
    var query = context.MyEntities.Select(entity => entity.Id).Contains(id);

    var results = query.ToList();
    ...
}
```

この例では、クエリ id の値が異なる次のクエリが実行されるたびには新しいプランにコンパイルされます。

特定に注意してください Skip と Take ページングを実施する際に使用します。 EF6 では、これらのメソッドは、実質的には、キャッシュされたクエリ プラン再利用可能な EF がこれらのメソッドに渡された変数のキャプチャし、Sqlparameter に変換するため、ラムダのオーバー ロードがあります。 これは、ため、各クエリの Skip と Take を異なる定数は、独自のクエリ プランのキャッシュ エントリを取得するそれ以外の場合、キャッシュをより明確な保持にも役立ちます。

次のようなコードが最適では、このクラスのクエリを体現だけを目的とを考慮してください。

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

これと同じコードの高速バージョンでは、ラムダでスキップを呼び出す必要があります。

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i \< count; ++i)
{
    var currentCustomer = customers.Skip(() => i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

2 番目のスニペットは、クエリが実行される CPU 時間を節約し、クエリ キャッシュを汚染することを回避するたびに、同じクエリ プランが使用されるため、最大 11% 高速化を実行できます。 さらに、スキップするパラメーターは、クロージャでは、コードもようになりますようになりました。

``` csharp
var i = 0;
var skippyCustomers = context.Customers.OrderBy(c => c.LastName).Skip(() => i);
for (; i < count; ++i)
{
    var currentCustomer = skippyCustomers.FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

### <a name="43-using-the-properties-of-a-non-mapped-object"></a>4.3、マップされていないオブジェクトのプロパティを使用します。

ときに、パラメーター、クエリがキャッシュされないが、クエリは、マップされていないオブジェクト型のプロパティを使用します。 例えば:

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();

    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myObject.MyProperty)
                select entity;

   var results = query.ToList();
    ...
}
```

この例では、クラス NonMappedType がエンティティ モデルの一部ではないことを想定しています。 このクエリは、マップされていない型を使用し、代わりにローカル変数をクエリにパラメーターとして使用する簡単に変更できます。

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();
    var myValue = myObject.MyProperty;
    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myValue)
                select entity;

    var results = query.ToList();
    ...
}
```

ここでは、クエリでは、キャッシュできなくなり、クエリ プランのキャッシュのパフォーマンスが得られます。

### <a name="44-linking-to-queries-that-require-recompiling"></a>4.4 リンクを再コンパイルを必要とするクエリ

上記と同じ例を次の 2 番目のクエリを再コンパイルする必要のあるクエリに依存しているがある場合、全体の 2 番目のクエリも再コンパイルされます。 このシナリオを説明する例を次に示します。

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var firstQuery = from entity in context.MyEntities
                        where ids.Contains(entity.Id)
                        select entity;

    var secondQuery = from entity in context.MyEntities
                        where firstQuery.Any(otherEntity => otherEntity.Id == entity.Id)
                        select entity;

    var results = secondQuery.ToList();
    ...
}
```

例は、ジェネリックですがどの firstQuery へのリンクの原因となって secondQuery キャッシュを取得できないようにすることを示しています。 FirstQuery で、再コンパイルを必要とするクエリがなかった場合、secondQuery はキャッシュされています。

## <a name="5-notracking-queries"></a>5 つのクエリの NoTracking

### <a name="51-disabling-change-tracking-to-reduce-state-management-overhead"></a>5.1 には、状態管理のオーバーヘッドを削減する変更追跡が無効にします。

読み取り専用のシナリオには、し、ObjectStateManager にオブジェクトの読み込みのオーバーヘッドを回避する場合は、「No 追跡」クエリを発行できます。  クエリ レベルでは、変更の追跡を無効にすることができます。

ただし、変更の追跡を無効にすると、効果的に変えることオブジェクトのキャッシュをオフにしてください。 エンティティのクエリを実行するときは、ObjectStateManager から既に具体化されたクエリの結果を取得することによって結果の具体化をスキップすることはできません。 繰り返し同じコンテキストで同じエンティティのクエリを実行する場合は、変更の追跡を有効化のメリットのパフォーマンスを実際に見ることがあります。

ObjectContext を使用してクエリを実行するときに、ObjectQuery および ObjectSet インスタンスは設定されているとしてで構成されているクエリは、親クエリの有効な MergeOption を継承、MergeOption が記憶されます。 DbContext を使用する場合は、AsNoTracking() 修飾子を呼び出して、DbSet の追跡を無効にできます。

#### <a name="511-disabling-change-tracking-for-a-query-when-using-dbcontext"></a>5.1.1 変更の DbContext を使用する場合は、クエリの追跡を無効にします。

クエリで AsNoTracking() メソッドの呼び出しを連鎖させることにより、クエリのモードを NoTracking を切り替えることができます。 ObjectQuery とは異なり、DbContext API のクラスの DbSet と DbQuery クラスは変更可能なプロパティを MergeOption の必要はありません。

``` csharp
    var productsForCategory = from p in context.Products.AsNoTracking()
                                where p.Category.CategoryName == selectedCategory
                                select p;


```

#### <a name="512-disabling-change-tracking-at-the-query-level-using-objectcontext"></a>5.1.2 ObjectContext を使用して、クエリ レベルで変更の追跡を無効にします。

``` csharp
    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;

    ((ObjectQuery)productsForCategory).MergeOption = MergeOption.NoTracking;
```

#### <a name="513-disabling-change-tracking-for-an-entire-entity-set-using-objectcontext"></a>5.1.3 ObjectContext を使用して設定全体のエンティティの変更の追跡を無効にします。

``` csharp
    context.Products.MergeOption = MergeOption.NoTracking;

    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;
```

### <a name="52-test-metrics-demonstrating-the-performance-benefit-of-notracking-queries"></a>5.2 NoTracking クエリのパフォーマンスの利点を示すメトリックをテストします。

このテストで Navision モデルに対するクエリを NoTracking する追跡を比較することによって、ObjectStateManager の入力が注目します。 Navision モデルと実行されたクエリの種類の説明については、付録を参照してください。 このテストでは、クエリのリストを反復処理し、それぞれを 1 回実行します。 "AppendOnly"の既定のマージ オプションを使用し、テスト、NoTracking クエリが 1 回に 1 回の 2 つのバリエーションをしました。 各バリエーションを 3 回実行し、実行の平均値を取得します。 テスト間は SQL Server でクエリ キャッシュをクリアし、次のコマンドを実行して、tempdb の圧縮します。

1.  DBCC DROPCLEANBUFFERS
2.  DBCC FREEPROCCACHE
3.  DBCC SHRINKDATABASE (tempdb、0)

テスト結果、中央値 3 を実行します。

|                        | ない追跡 – ワーキング セット | 追跡なし – 時間 | ワーキング セットにのみ – 追加します。 | のみ: 時間の追加します。 |
|:-----------------------|:--------------------------|:-------------------|:--------------------------|:-------------------|
| **Entity Framework 5** | 460361728                 | 1163536 ms         | 596545536                 | 1273042 ms         |
| **Entity Framework 6** | 647127040                 | 190228 ms          | 832798720                 | 195521 ms          |

Entity Framework 5 は、小さいメモリ フット プリントが、実行の最後に Entity Framework 6 よりも必要があります。 Entity Framework 6 で使用される追加のメモリは、追加のメモリ構造体と新機能とパフォーマンスの向上を実現するコードの結果です。

違いがあるもクリアのメモリ使用量、ObjectStateManager を使用する場合。 Entity Framework 5 は、データベースから具体化すべてのエンティティを追跡するときに 30% のフット プリントを増加します。 Entity Framework 6 は、そのときに、28% によってそのフット プリントを向上します。

時間で Entity Framework 6 先、大規模な余白によってこのテストでの Entity Framework 5 を進んでいます。 Entity Framework 6 には、Entity Framework 5 で使用された時間の約 16% のテストが完了しました。 さらに、Entity Framework 5 には、ObjectStateManager が使用されているときに完了する 9% 以上の時間がかかります。 比較では、Entity Framework 6 が 3%、ObjectStateManager を使用するときに多くの時間を使用しています。

## <a name="6-query-execution-options"></a>6 つのクエリ実行オプション

Entity Framework では、クエリをいくつかの方法を提供します。 次のオプションについて見て、長所と短所、それぞれの比較やそのパフォーマンス特性を確認します。

-   LINQ to Entities。
-   追跡なし LINQ to Entities。
-   ObjectQuery 経由で SQL のエンティティ。
-   EntityCommand を経由で SQL のエンティティ。
-   ExecuteStoreQuery します。
-   SqlQuery します。
-   CompiledQuery します。

### <a name="61-------linq-to-entities-queries"></a>6.1 LINQ to Entities クエリ

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

**プロフェッショナル**

-   CUD 操作に適しています。
-   完全に具体化されたオブジェクト。
-   構文で記述する最も簡単なプログラミング言語に組み込まれています。
-   適切なパフォーマンス。

**短所**

-   特定の技術的な制限事項など。
    -   OUTER JOIN クエリ DefaultIfEmpty の使用パターンは、Entity SQL での単純な OUTER JOIN ステートメントよりも複雑なクエリで発生します。
    -   使用できない場合が一般的なパターンに一致するような。

### <a name="62-------no-tracking-linq-to-entities-queries"></a>6.2 なしの追跡 LINQ to Entities クエリ

ときに、コンテキストは、ObjectContext を派生します。

``` csharp
context.Products.MergeOption = MergeOption.NoTracking;
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

ときに、コンテキストでは、DbContext が派生します。

``` csharp
var q = context.Products.AsNoTracking()
                        .Where(p => p.Category.CategoryName == "Beverages");
```

**プロフェッショナル**

-   定期的な LINQ クエリでパフォーマンスが向上します。
-   完全に具体化されたオブジェクト。
-   構文で記述する最も簡単なプログラミング言語に組み込まれています。

**短所**

-   CUD 操作には適していません。
-   特定の技術的な制限事項など。
    -   OUTER JOIN クエリ DefaultIfEmpty の使用パターンは、Entity SQL での単純な OUTER JOIN ステートメントよりも複雑なクエリで発生します。
    -   使用できない場合が一般的なパターンに一致するような。

スカラー プロパティを射影するクエリは、NoTracking が指定されていない場合でも追跡されないことに注意してください。 例えば:

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages").Select(p => new { p.ProductName });
```

この特定のクエリの NoTracking、されているが明示的に指定しますが、いない具体化することがあるため、型が知られているオブジェクトの状態マネージャーから具体化された結果は追跡されません。

### <a name="63-------entity-sql-over-an-objectquery"></a>6.3 entity SQL で ObjectQuery

``` csharp
ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
```

**プロフェッショナル**

-   CUD 操作に適しています。
-   完全に具体化されたオブジェクト。
-   サポートは、プランのキャッシュをクエリします。

**短所**

-   ユーザー エラーよりやすい言語に組み込まれているクエリの構造はテキスト形式のクエリ文字列が含まれます。

### <a name="64-------entity-sql-over-an-entity-command"></a>6.4 エンティティ、エンティティ コマンド経由で SQL

``` csharp
EntityCommand cmd = eConn.CreateCommand();
cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
{
    while (reader.Read())
    {
        // manually 'materialize' the product
    }
}
```

**プロフェッショナル**

-   サポートは、.NET 4.0 では (.NET 4.5 では他のクエリの種類をすべてでサポートは、プランのキャッシュ) プランのキャッシュをクエリします。

**短所**

-   ユーザー エラーよりやすい言語に組み込まれているクエリの構造はテキスト形式のクエリ文字列が含まれます。
-   CUD 操作には適していません。
-   結果は自動的に具体化されていないと、データ リーダーから読み取る必要があります。

### <a name="65-------sqlquery-and-executestorequery"></a>6.5 SqlQuery と ExecuteStoreQuery

データベースで SqlQuery:

``` csharp
// use this to obtain entities and not track them
var q1 = context.Database.SqlQuery<Product>("select * from products");
```

DbSet に SqlQuery:

``` csharp
// use this to obtain entities and have them tracked
var q2 = context.Products.SqlQuery("select * from products");
```

ExecyteStoreQuery:

``` csharp
var beverages = context.ExecuteStoreQuery<Product>(
@"     SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued, P.DiscontinuedDate
       FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
       WHERE        (C.CategoryName = 'Beverages')"
);
```

**プロフェッショナル**

-   一般に最速のパフォーマンス計画のコンパイラがバイパスされるためです。
-   完全に具体化されたオブジェクト。
-   CUD 操作、DbSet から使用する場合に適しています。

**短所**

-   クエリがテキストの場合、エラーが発生します。
-   クエリは、概念のセマンティクスではなく、ストア セマンティクスを使用して、特定のバックエンドに関連付けられます。
-   継承が存在する場合は、手動作成したクエリは、要求された型のマッピングの条件を考慮する必要があります。

### <a name="66-------compiledquery"></a>6.6 CompiledQuery

``` csharp
private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
    (NorthwindEntities context, string categoryName) =>
        context.Products.Where(p => p.Category.CategoryName == categoryName)
        );
…
var q = context.InvokeProductsForCategoryCQ("Beverages");
```

**プロフェッショナル**

-   定期的な LINQ クエリで最大 7% のパフォーマンス向上を提供します。
-   完全に具体化されたオブジェクト。
-   CUD 操作に適しています。

**短所**

-   複雑さとオーバーヘッドのプログラミングを向上します。
-   パフォーマンスの向上は、コンパイル済みクエリ上に作成するときに失われます。
-   CompiledQuery - 匿名型のプロジェクションなどとしては、いくつかの LINQ クエリを記述することはできません。

### <a name="67-------performance-comparison-of-different-query-options"></a>6.7 別のクエリ オプションのパフォーマンス比較

テストにコンテキストの作成がタイムアウトしたいない単純な microbenchmarks に配置されています。 一連の管理された環境でのエンティティの非キャッシュの 5000 回のクエリを測定しました。 これらの数値が警告を実行するには: アプリケーションによって生成された実際の数値は反映されませんが、どれだけが異なるクエリのオプションを比較するとパフォーマンスの違いの非常に正確な測定では代わりに-公正、新しいコンテキストを作成するコストを除外します。

| EF  | テスト                                 | 時間 (ミリ秒) | メモリ   |
|:----|:-------------------------------------|:----------|:---------|
| EF5 | ObjectContext ESQL                   | 2414      | 38801408 |
| EF5 | ObjectContext の Linq クエリ             | 2692      | 38277120 |
| EF5 | DbContext Linq には、追跡をクエリなし     | 2818      | 41840640 |
| EF5 | DbContext の Linq クエリ                 | 2930      | 41771008 |
| EF5 | ObjectContext の Linq には、追跡をクエリなし | 3013      | 38412288 |
|     |                                      |           |          |
| EF6 | ObjectContext ESQL                   | 2059      | 46039040 |
| EF6 | ObjectContext の Linq クエリ             | 3074      | 45248512 |
| EF6 | DbContext Linq には、追跡をクエリなし     | 3125      | 47575040 |
| EF6 | DbContext の Linq クエリ                 | 3420      | 47652864 |
| EF6 | ObjectContext の Linq には、追跡をクエリなし | 3593      | 45260800 |

![EF5 ミクロ ベンチマーク、5000 ウォーム イテレーション](~/ef6/media/ef5micro5000warm.png)

![EF6 ミクロ ベンチマーク、5000 ウォーム イテレーション](~/ef6/media/ef6micro5000warm.png)

Microbenchmarks は非常に重視するコードに小さな変更です。 Entity Framework 5 のコストと Entity Framework 6 の違いが追加されるため、この場合、[インターセプション](~/ef6/fundamentals/logging-and-interception.md)と[トランザクションの機能強化](~/ef6/saving/transactions.md)します。 これらの microbenchmarks 番号では、増幅のビジョンの Entity Framework では非常に小さいフラグメントをただしは。 ウォーム クエリの実際のシナリオでは Entity Framework 6 Entity Framework 5 からアップグレードすると、パフォーマンスの低下は表示されません。

別のクエリ オプションの実際のパフォーマンスを比較するには、5 つの別個のテスト バリエーションは「飲み物」のカテゴリ名を持つすべての製品を選択する別のクエリ オプションを使用しますを作成しました。 各イテレーションには、コンテキストの作成のコストと、返されたすべてのエンティティの具体化のコストが含まれています。 イテレーションは 10 回は、タイムアウトになりました 1000 回の繰り返しの合計を実行する前に untimed で実行されます。 表示される結果は、各テストの回数が 5 回から中央値、実行します。 詳細については、テストのコードを含む付録 B を参照してください。

| EF  | テスト                                        | 時間 (ミリ秒) | メモリ   |
|:----|:--------------------------------------------|:----------|:---------|
| EF5 | ObjectContext エンティティ コマンド                | 621       | 39350272 |
| EF5 | データベースに対する Sql クエリを DbContext             | 825       | 37519360 |
| EF5 | ObjectContext のストアのクエリ                   | 878       | 39460864 |
| EF5 | ObjectContext の Linq には、追跡をクエリなし        | 969       | 38293504 |
| EF5 | ObjectContext の Entity Sql クエリのオブジェクトを使用します。 | 1089      | 38981632 |
| EF5 | コンパイル済みクエリの ObjectContext                | 1099      | 38682624 |
| EF5 | ObjectContext の Linq クエリ                    | 1152      | 38178816 |
| EF5 | DbContext Linq には、追跡をクエリなし            | 1208      | 41803776 |
| EF5 | DbSet に DbContext Sql クエリ                | 1414      | 37982208 |
| EF5 | DbContext の Linq クエリ                        | 1574      | 41738240 |
|     |                                             |           |          |
| EF6 | ObjectContext エンティティ コマンド                | 480       | 47247360 |
| EF6 | ObjectContext のストアのクエリ                   | 493       | 46739456 |
| EF6 | データベースに対する Sql クエリを DbContext             | 614       | 41607168 |
| EF6 | ObjectContext の Linq には、追跡をクエリなし        | 684       | 46333952 |
| EF6 | ObjectContext の Entity Sql クエリのオブジェクトを使用します。 | 767       | 48865280 |
| EF6 | コンパイル済みクエリの ObjectContext                | 788       | 48467968 |
| EF6 | DbContext Linq には、追跡をクエリなし            | 878       | 47554560 |
| EF6 | ObjectContext の Linq クエリ                    | 953       | 47632384 |
| EF6 | DbSet に DbContext Sql クエリ                | 1023      | 41992192 |
| EF6 | DbContext の Linq クエリ                        | 1290      | 47529984 |


![EF5 ウォーム クエリ 1000 のイテレーション](~/ef6/media/ef5warmquery1000.png)

![EF6 ウォーム クエリ 1000 のイテレーション](~/ef6/media/ef6warmquery1000.png)

> [!NOTE]
> 完全を期すため、EntityCommand を Entity SQL クエリを実行バリエーションの 1 つが含まれます。 ただし、そのようなクエリは結果を具体化されません、ため、比較は必ずしも公正にします。 テストには、近似値してみること、比較を公平に具体化にはが含まれています。

このエンド ツー エンドの場合は、Entity Framework 6 は、はるかに軽量の DbContext の初期化と高速 MetadataCollection を含む、スタックの複数の部分のパフォーマンス強化による Entity Framework 5 をよりも&lt;T&gt;参照します。

## <a name="7-design-time-performance-considerations"></a>7 の設計時のパフォーマンスの考慮事項

### <a name="71-------inheritance-strategies"></a>7.1 の継承方法

別のパフォーマンスの考慮事項 Entity Framework を使用する場合は、使用する継承戦略です。 Entity Framework には、3 の基本的な種類の継承とそれらの組み合わせがサポートされています。

-   テーブルごとの階層 (TPH) – 各継承が行で表現されて、階層内でどの特定の種類を示す識別子列を持つテーブルにマップを設定します。
-   テーブルごとの種類 (TPT) – それぞれの種類がデータベースでは、独自のテーブルを持ちます子テーブルは、親テーブルが含まれていない列を定義するだけです。
-   テーブルあたりクラス (TPC) – それぞれの種類がデータベースでは、独自の完全なテーブルを持ちます子テーブルでは、親の型で定義されているものも含め、すべてのフィールドを定義します。

モデルは、TPT 継承を使用している場合、生成されたクエリは、他の継承方法、ストアの実行時間が長いになる可能性がありますで生成されるよりも複雑になります。  一般的に時間がかかります、TPT モデルに対するクエリを生成して、結果のオブジェクトを具体化します。

「パフォーマンスの考慮事項 (テーブルの種類ごと) TPT 継承を Entity Framework を使用する場合"を参照してください。 MSDN ブログの投稿: \<http://blogs.msdn.com/b/adonet/archive/2010/08/17/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework.aspx>します。

#### <a name="711-------avoiding-tpt-in-model-first-or-code-first-applications"></a>7.1.1 Model First または Code First アプリケーションで TPT の回避

TPT スキーマを持つ既存のデータベース上にモデルを作成するときに、多くのオプションがありません。 Model First または Code First を使用してアプリケーションを作成する場合は、TPT 継承のパフォーマンスの問題を避ける必要があります。

エンティティ デザイナーのウィザードで Model First を使用すると、モデル内の任意の継承 TPT が表示されます。 Visual Studio ギャラリーから"エンティティ デザイナー データベース生成 Power Pack"使用可能なを使用するには Model First と TPH 継承戦略に切り替える場合は、( \<http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>)します。

Code First を使用して継承でモデルのマッピングを構成する場合は、EF は、TPH を使用して既定では、ため、継承階層内のすべてのエンティティに同じテーブルにマップされます。 MSDN マガジンで「コード最初エンティティ Framework4.1 をでいます」記事の"マッピングに Fluent API"を参照してください ( [ http://msdn.microsoft.com/magazine/hh126815.aspx ](https://msdn.microsoft.com/magazine/hh126815.aspx)) の詳細。

### <a name="72-------upgrading-from-ef4-to-improve-model-generation-time"></a>7.2 は、モデルの生成を向上させるために EF4 からアップグレードする時間

モデルのストア層 (SSDL) を生成するアルゴリズムに SQL Server に固有の向上は、Visual Studio 2010 SP1 がインストールされているときに Entity Framework 4 への更新および Entity Framework 5 および 6 で利用できます。 次のテスト結果は場合 Navision モデルはこれで、非常に大きなモデルを生成するときに、向上を示します。 詳細については、付録 C を参照してください。

モデルには、1005 エンティティ セットおよび 4227 のアソシエーション セットが含まれています。

| 構成                              | 消費された時間の内訳                                                                                                                                               |
|:-------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Visual Studio 2010 で Entity Framework 4     | SSDL の生成: 2 時間の 27 分 <br/> 1 秒間のマッピングの生成: <br/> CSDL の生成: 1 秒 <br/> ObjectLayer 生成: 1 秒 <br/> ビューの生成: 2 時間 14 分 |
| Visual Studio 2010 SP1、Entity Framework 4 | SSDL の生成: 1 秒 <br/> 1 秒間のマッピングの生成: <br/> CSDL の生成: 1 秒 <br/> ObjectLayer 生成: 1 秒 <br/> ビューの生成: 1 時間 53 分   |
| Visual Studio 2013 で Entity Framework 5     | SSDL の生成: 1 秒 <br/> 1 秒間のマッピングの生成: <br/> CSDL の生成: 1 秒 <br/> ObjectLayer 生成: 1 秒 <br/> ビューの生成: 65 分    |
| Visual Studio 2013 で Entity Framework 6     | SSDL の生成: 1 秒 <br/> 1 秒間のマッピングの生成: <br/> CSDL の生成: 1 秒 <br/> ObjectLayer 生成: 1 秒 <br/> ビューの生成: 28 秒。   |


SSDL を生成するときに、負荷がほぼ完全で消費 SQL Server では、クライアントの開発用コンピューターが待機している間に注目すべきアイドル状態が、サーバーから返される結果。 Dba は、この機能強化を特に感謝する必要があります。 行われるビューの生成でを今すぐコストは、モデルの生成の本質的には全体の注目すべきです。

### <a name="73-------splitting-large-models-with-database-first-and-model-first"></a>7.3 データベースでの大規模なモデルを最初に分割して、最初のモデル

モデルのサイズの増大に合わせて、デザイナー画面が乱雑および使用するが困難になります。 ここには、300 を超えるエンティティを効果的にデザイナーを使用するには大きすぎると、モデル通常検討してください。 次のブログの投稿が大規模なモデルを分割するためのいくつかのオプションについて説明します。 \<http://blogs.msdn.com/b/adonet/archive/2008/11/25/working-with-large-models-in-entity-framework-part-2.aspx>します。

投稿は、Entity Framework の最初のバージョンとして記述されましたが、手順が引き続き適用されます。

### <a name="74-------performance-considerations-with-the-entity-data-source-control"></a>7.4 エンティティのデータ ソース コントロールにのパフォーマンスに関する考慮事項

EntityDataSource コントロールを使用して web アプリケーションのパフォーマンスが大幅に低下マルチ スレッドのパフォーマンスとストレス テスト内のケースを説明しました。 基になる原因は、EntityDataSource は、エンティティとして使用する種類を検出する Web アプリケーションによって参照されるアセンブリの MetadataWorkspace.LoadFromAssembly を繰り返し呼び出します。

ソリューションでは、ObjectContext は、派生クラスの型名を EntityDataSource の ContextTypeName を設定します。 エンティティ型のすべての参照アセンブリをスキャンするメカニズムをオフにします。

今回は ContextTypeName フィールドを設定すると、リフレクションを使用してアセンブリから型を読み込めない場合に、.NET 4.0 で EntityDataSource が ReflectionTypeLoadException をスローする場所、機能の問題も回避されます。 この問題は .NET 4.5 で修正されました。

### <a name="75-------poco-entities-and-change-tracking-proxies"></a>POCO エンティティと変更追跡プロキシを 7.5

Entity Framework では、データ クラス自体に変更を加えずに、データ モデルと共にカスタム データ クラスを使用することができます。 つまり、既存のドメイン オブジェクトなどの POCO ("plain-old" CLR object) をデータ モデルで使用できます。 同じクエリのほとんどをサポートして挿入、更新、および Entity Data Model ツールによって生成されるエンティティ型としての動作を削除にデータ モデルで定義されているエンティティにマップされます、こうした POCO データ クラス (永続化非依存オブジェクトとも呼ばれます)。

Entity Framework は、自動変更の追跡 POCO エンティティを遅延読み込みなどの機能を有効にするときに使用される POCO 型から派生したプロキシ クラスを作成することもできます。 POCO クラスは、ここで説明したように、プロキシを使用する Entity Framework を許可する特定の要件を満たす必要があります: [ http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx)します。

可能性の追跡プロキシは、オブジェクト状態マネージャーを毎回変更されると、その値は、Entity Framework は、エンティティの実際の状態を常にわかるように、エンティティのプロパティのいずれかが通知されます。 これは、プロパティの setter メソッドの本体を通知イベントを追加し、オブジェクト状態マネージャーでこのようなイベントを処理します。 プロキシを作成するエンティティは通常注は、追加した一連の Entity Framework によって作成されたイベントのためのプロキシではない POCO エンティティを作成するよりも高価でください。

POCO エンティティが、変更追跡プロキシを持たない場合に、以前保存された状態のコピーに対して、エンティティの内容を比較することによって変更が見つかりました。 この詳細な比較になります時間のかかるプロセスにおいては、多数のエンティティがある場合、またはエンティティがある非常に大量のプロパティ の場合に最後の比較が行われた後に変更しない場合でもです。

概要: パフォーマンス変更追跡プロキシを作成するときに料金がかかりますが、変更の追跡に役立つ、エンティティは、多くのプロパティまたはモデルに多数のエンティティがある場合がある場合は、変更の検出プロセスを高速化します。 プロパティは、エンティティの量膨大にならないほどの数が少ないエンティティは、変更追跡プロキシを持つできない場合がありますのメリットです。

## <a name="8-loading-related-entities"></a>8 の読み込みに関連するエンティティ

### <a name="81-lazy-loading-vs-eager-loading"></a>8.1 の遅延読み込みと一括読み込み

Entity Framework では、いくつかのターゲット エンティティに関連するエンティティを読み込む方法を提供します。 たとえば、製品を照会するときに方法はありますいる、関連する注文が読み込まれるオブジェクトの状態マネージャーにします。 パフォーマンスの観点から、関連エンティティを読み込むときに考慮する最大の質問は Lazy Loading と Eager Loading 使用するかになります。

Eager Loading を使用する場合、ターゲット エンティティ セットと一緒に関連エンティティが読み込まれます。 関連プッシュしたいエンティティを示す、クエリで Include ステートメントを使用します。

Lazy Loading を使用する場合、ターゲット エンティティ セットにのみ、最初のクエリが表示されます。 別のクエリが、関連するエンティティを読み込むストアに対して発行されたナビゲーション プロパティにアクセスするたびにします。

エンティティが読み込まれた後にエンティティのクエリから直接読み込むオブジェクト状態マネージャーで、遅延読み込みまたは一括読み込みを使用しているかどうか。

### <a name="82-how-to-choose-between-lazy-loading-and-eager-loading"></a>8.2 Lazy Loading と Eager Loading の選択方法

重要な点は、アプリケーションの適切な選択を行うことができますように Lazy Loading と Eager Loading の違いを理解することです。 これからは、大きなペイロードを含む可能性のある 1 つの要求ではなく、データベースに対して複数の要求間のトレードオフを評価できます。 他の部分で、アプリケーションの一部の一括読み込みと遅延読み込みを使用する適切な場合があります。

内部的には何が起こっているかの例は、英国およびその注文数に居住する顧客に対してクエリを実行するとします。

**一括読み込みを使用します。**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var ukCustomers = context.Customers.Include(c => c.Orders).Where(c => c.Address.Country == "UK");
    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

**遅延読み込みを使用します。**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    context.ContextOptions.LazyLoadingEnabled = true;

    //Notice that the Include method call is missing in the query
    var ukCustomers = context.Customers.Where(c => c.Address.Country == "UK");

    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

一括読み込みを使用する場合は、すべての顧客を返す 1 つのクエリを発行し、すべての注文します。 ストア コマンドは、ようになります。

``` SQL
SELECT
[Project1].[C1] AS [C1],
[Project1].[CustomerID] AS [CustomerID],
[Project1].[CompanyName] AS [CompanyName],
[Project1].[ContactName] AS [ContactName],
[Project1].[ContactTitle] AS [ContactTitle],
[Project1].[Address] AS [Address],
[Project1].[City] AS [City],
[Project1].[Region] AS [Region],
[Project1].[PostalCode] AS [PostalCode],
[Project1].[Country] AS [Country],
[Project1].[Phone] AS [Phone],
[Project1].[Fax] AS [Fax],
[Project1].[C2] AS [C2],
[Project1].[OrderID] AS [OrderID],
[Project1].[CustomerID1] AS [CustomerID1],
[Project1].[EmployeeID] AS [EmployeeID],
[Project1].[OrderDate] AS [OrderDate],
[Project1].[RequiredDate] AS [RequiredDate],
[Project1].[ShippedDate] AS [ShippedDate],
[Project1].[ShipVia] AS [ShipVia],
[Project1].[Freight] AS [Freight],
[Project1].[ShipName] AS [ShipName],
[Project1].[ShipAddress] AS [ShipAddress],
[Project1].[ShipCity] AS [ShipCity],
[Project1].[ShipRegion] AS [ShipRegion],
[Project1].[ShipPostalCode] AS [ShipPostalCode],
[Project1].[ShipCountry] AS [ShipCountry]
FROM ( SELECT
      [Extent1].[CustomerID] AS [CustomerID],
       [Extent1].[CompanyName] AS [CompanyName],
       [Extent1].[ContactName] AS [ContactName],
       [Extent1].[ContactTitle] AS [ContactTitle],
       [Extent1].[Address] AS [Address],
       [Extent1].[City] AS [City],
       [Extent1].[Region] AS [Region],
       [Extent1].[PostalCode] AS [PostalCode],
       [Extent1].[Country] AS [Country],
       [Extent1].[Phone] AS [Phone],
       [Extent1].[Fax] AS [Fax],
      1 AS [C1],
       [Extent2].[OrderID] AS [OrderID],
       [Extent2].[CustomerID] AS [CustomerID1],
       [Extent2].[EmployeeID] AS [EmployeeID],
       [Extent2].[OrderDate] AS [OrderDate],
       [Extent2].[RequiredDate] AS [RequiredDate],
       [Extent2].[ShippedDate] AS [ShippedDate],
       [Extent2].[ShipVia] AS [ShipVia],
       [Extent2].[Freight] AS [Freight],
       [Extent2].[ShipName] AS [ShipName],
       [Extent2].[ShipAddress] AS [ShipAddress],
       [Extent2].[ShipCity] AS [ShipCity],
       [Extent2].[ShipRegion] AS [ShipRegion],
       [Extent2].[ShipPostalCode] AS [ShipPostalCode],
       [Extent2].[ShipCountry] AS [ShipCountry],
      CASE WHEN ([Extent2].[OrderID] IS NULL) THEN CAST(NULL AS int) ELSE 1 END AS [C2]
      FROM  [dbo].[Customers] AS [Extent1]
      LEFT OUTER JOIN [dbo].[Orders] AS [Extent2] ON [Extent1].[CustomerID] = [Extent2].[CustomerID]
      WHERE N'UK' = [Extent1].[Country]
)  AS [Project1]
ORDER BY [Project1].[CustomerID] ASC, [Project1].[C2] ASC
```

遅延読み込みを使用する場合は、最初に、次のクエリを発行します。

``` SQL
SELECT
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[CompanyName] AS [CompanyName],
[Extent1].[ContactName] AS [ContactName],
[Extent1].[ContactTitle] AS [ContactTitle],
[Extent1].[Address] AS [Address],
[Extent1].[City] AS [City],
[Extent1].[Region] AS [Region],
[Extent1].[PostalCode] AS [PostalCode],
[Extent1].[Country] AS [Country],
[Extent1].[Phone] AS [Phone],
[Extent1].[Fax] AS [Fax]
FROM [dbo].[Customers] AS [Extent1]
WHERE N'UK' = [Extent1].[Country]
```

顧客の注文のナビゲーション プロパティにアクセスするたびに、次のような別のクエリは、ストアに対して発行します。

``` SQL
exec sp_executesql N'SELECT
[Extent1].[OrderID] AS [OrderID],
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[EmployeeID] AS [EmployeeID],
[Extent1].[OrderDate] AS [OrderDate],
[Extent1].[RequiredDate] AS [RequiredDate],
[Extent1].[ShippedDate] AS [ShippedDate],
[Extent1].[ShipVia] AS [ShipVia],
[Extent1].[Freight] AS [Freight],
[Extent1].[ShipName] AS [ShipName],
[Extent1].[ShipAddress] AS [ShipAddress],
[Extent1].[ShipCity] AS [ShipCity],
[Extent1].[ShipRegion] AS [ShipRegion],
[Extent1].[ShipPostalCode] AS [ShipPostalCode],
[Extent1].[ShipCountry] AS [ShipCountry]
FROM [dbo].[Orders] AS [Extent1]
WHERE [Extent1].[CustomerID] = @EntityKeyValue1',N'@EntityKeyValue1 nchar(5)',@EntityKeyValue1=N'AROUT'
```

詳細については、次を参照してください。、[関連オブジェクトの読み込み](https://msdn.microsoft.com/library/bb896272.aspx)します。

#### <a name="821-lazy-loading-versus-eager-loading-cheat-sheet"></a>8.2.1 遅延読み込みと Eager Loading チート シート

遅延読み込みと一括読み込みを選択するという、画一的なものはありません。 最初に両方の戦略; も十分な情報に基づいて意思決定を行うことができますので違いについて理解するにはまた、次のシナリオのいずれかに、コードに対応するかどうかに検討してください。

| シナリオ                                                                    | 私たちの提案                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|:----------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| フェッチされたエンティティから多くのナビゲーション プロパティにアクセスする必要がありますか。 | **いいえ**-両方のオプションが行う可能性があります。 ただし、クエリ結果のペイロードが大きすぎるため、小さい必要がありますが、一括読み込みを使用して、パフォーマンス上の利点がありますがない場合、オブジェクトを具体化するためのラウンド トリップをネットワークします。 <br/> <br/> **[はい]** -エンティティから多くのナビゲーション プロパティにアクセスする必要がある場合、複数を使用して、クエリの一括読み込みでのステートメント含めることを行うとします。 複数のエンティティを含めると、サイズが大きくなるほど、ペイロードが返されます。 次の 3 つ以上のエンティティをクエリに含めると、読み込む非同期 (lazy) への切り替えを検討してください。 |
| 実行時にどのようなデータが必要になります正確をご存知でしょうか。                   | **いいえ**-遅延読み込みをすることをお勧めになります。 それ以外の場合、データのクエリを実行する必要はありません最終的にすることがあります。 <br/> <br/> **[はい]** - Eager の読み込みは、おそらく最善の方法です。 セット全体の読み込みが速くなりますのに役立ちます。 クエリでは、非常に大量のデータをフェッチしていますが必要ですされ、これが遅すぎるから読み込む代わりに非同期 (lazy) を再試行してください。                                                                                                                                                                                                                                                       |
| データベースから遠く離れた、コードを実行しますか。 (強化されたネットワークの待機時間)  | **いいえ**ネットワーク待機時間は、問題がない場合 - 遅延読み込みを使用すると、コードが簡略化されます。 アプリケーションのトポロジが変わったり、当たり前のデータベースの近接性を使用しないように注意してください。 <br/> <br/> **[はい]** - ネットワークには、問題があるシナリオより適切に合ったものを決定できます専用です。 通常より少ないラウンド トリップを必要とするため、一括読み込みは改善されます。                                                                                                                                                                                                      |


#### <a name="822-------performance-concerns-with-multiple-includes"></a>8.2.2 複数含むパフォーマンスの問題

サーバー応答時間に関する問題に関連するパフォーマンスに関する質問を聞くことと、問題の原因が頻繁に複数の Include ステートメントを使用したクエリにします。 関連エンティティを含むクエリでは、強力なは、内部で何が起こっているかを理解する必要があります。

ストア コマンドを生成するために、プランを内部コンパイラを経由することで複数の Include ステートメントを持つクエリの比較的長い時間がかかります。 結果のクエリを最適化しようとしています。 この時間の大部分が費やされます。 生成されたストア コマンドには、マッピングによって、各に Outer Join または共用体が含まれます。 このようなクエリが (たとえば、Include の複数のレベルを使用して走査するペイロード内の冗長性の多くがある場合に特に、帯域幅の問題を acerbate は単一のペイロードで、データベースから大きな接続されているグラフに表示されます。アソシエーションの一対多方向)。

場合、クエリが ToTraceString の使用と、ペイロード サイズを表示する SQL Server Management Studio でストア コマンドを実行したクエリの基になる TSQL へのアクセスを非常に大きなペイロードを返すは場所を確認できます。 軽減しようとすることができます、このような場合だけに、クエリで Include ステートメントの数を必要なデータを取り込みます。 または、たとえば、サブクエリの小さいシーケンスに、クエリを分割することができます。

**前に、クエリが侵入します。**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var customers = from c in context.Customers.Include(c => c.Orders)
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

**クエリの重大な: の後**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var orders = from o in context.Orders
                 where o.Customer.LastName.StartsWith(lastNameParameter)
                 select o;

    orders.Load();

    var customers = from c in context.Customers
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

私たちは、追跡対象のクエリでのみ使用できるコンテキストは、identity の解像度との関連付けの修正を自動的に実行する必要がありますを使用します。

遅延読み込みと同様のトレードオフをより小さいペイロードのより多くのクエリとなります。 エンティティごとから必要なデータのみを明示的に選択する個々 のプロパティのプロジェクションを使用することもできますが、するは読み込まれていないエンティティここと更新はサポートされていません。

#### <a name="823-workaround-to-get-lazy-loading-of-properties"></a>8.2.3 回避策は、プロパティの遅延読み込みを取得するには

現在 entity Framework は、スカラーまたは複合プロパティの遅延読み込みをサポートしていません。 ただし、BLOB などのラージ オブジェクトを含むテーブルがある場合、テーブル分割を使用、大きなプロパティを個別のエンティティに分割します。 たとえば、varbinary フォト列を含む製品テーブルがあるとします。 多くの場合、クエリ内でこのプロパティにアクセスする必要はない場合、は、通常必要があるエンティティの部分のみを分割するテーブルを使用できます。 製品の写真を表すエンティティが明示的に必要なときにのみ読み込まれます。

テーブル分割を有効にする方法を示す適切なリソースは、Gil Fink の"テーブル分割の Entity Framework"ブログの投稿: \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>します。

## <a name="9-other-considerations"></a>9 他の考慮事項

### <a name="91------server-garbage-collection"></a>9.1 サーバーのガベージ コレクション

一部のユーザー、ガベージ コレクターが正しく構成されていない場合に予想されるは、並列処理を制限するリソースの競合が発生する可能性があります。 EF がマルチ スレッドのシナリオで使用されるか、サーバー側のシステムのような任意のアプリケーションで、必ずサーバーのガベージ コレクションを有効にします。 これは、アプリケーション構成ファイルの簡単な設定を使用して行います。

``` xml
<?xmlversion="1.0" encoding="utf-8" ?>
<configuration>
        <runtime>
               <gcServer enabled="true" />
        </runtime>
</configuration>
```

スレッドの競合を減らすし、CPU が飽和状態のシナリオで最大 30% してスループットを増やすこのする必要があります。 一般的な用語では、常に、アプリケーションの動作 (これはより適切な UI とクライアント側のシナリオ) クラシックのガベージ コレクションを使用してサーバーのガベージ コレクションとをテストする必要があります。

### <a name="92------autodetectchanges"></a>9.2 AutoDetectChanges

前述のように、Entity Framework はオブジェクト キャッシュに多数のエンティティがある場合にパフォーマンスの問題を表示可能性があります。 追加、削除、検索、エントリおよび SaveChanges などの特定の操作では、大量のオブジェクト キャッシュにどのくらいなったに基づいて CPU を消費する可能性があります DetectChanges への呼び出しをトリガーします。 この理由は、オブジェクト キャッシュとオブジェクトの状態マネージャーとして常にお試しがコンテキストに実行されるので、生成されたデータのさまざまなシナリオで正しいことが保証されて操作のたびにできるだけ同期されたことです。

一般に、Entity Framework の変更の自動検出が、アプリケーションの有効期間にわたって有効のままにすることをお勧めします。 高い CPU 使用率が悪影響を及ぼす影響されるシナリオと、プロファイルの場合、原因が DetectChanges への呼び出しであることを示す、コードの重要な部分で一時的にオフ AutoDetectChanges を検討してください。

``` csharp
try
{
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    ...
}
finally
{
    context.Configuration.AutoDetectChangesEnabled = true;
}
```

AutoDetectChanges を切る前に、Entity Framework エンティティで実行されている変更に関する特定の情報を追跡するには、その機能が失われる可能性を理解することをお勧めします。 正しく処理されない場合、アプリケーションでデータの不整合が発生する可能性があります。 AutoDetectChanges をオフにする詳細については、読み取る\<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>します。

### <a name="93------context-per-request"></a>9.3 要求ごとのコンテキスト

Entity Framework のコンテキストは、発生する最適なパフォーマンスを提供するために有効期間が短いインスタンスとして使用するものです。 コンテキストが短くなると予想される有効期間し、破棄されるので、そのため、reutilize 可能であれば、メタデータと非常に軽量な実装されているとします。 Web シナリオでは、この点に注意しないコンテキストを持っている 1 つの要求の期間より多くの重要なは。 同様に、web 以外のシナリオでコンテキストを破棄する Entity Framework でのキャッシュのさまざまなレベルの理解に基づいて。 一般に、アプリケーションだけでなく、1 つのスレッドのコンテキストと静的コンテキストの有効期間にわたってコンテキスト インスタンスを持つ 1 つは避ける必要があります。

### <a name="94------database-null-semantics"></a>9.4 データベースの null セマンティクス

既定では、entity Framework では、C が SQL コードを生成します。\#比較セマンティクスは null です。 次のクエリ例を検討してください。

``` csharp
            int? categoryId = 7;
            int? supplierId = 8;
            decimal? unitPrice = 0;
            short? unitsInStock = 100;
            short? unitsOnOrder = 20;
            short? reorderLevel = null;

            var q = from p incontext.Products
                    wherep.Category.CategoryName == "Beverages"
                          || (p.CategoryID == categoryId
                                || p.SupplierID == supplierId
                                || p.UnitPrice == unitPrice
                                || p.UnitsInStock == unitsInStock
                                || p.UnitsOnOrder == unitsOnOrder
                                || p.ReorderLevel == reorderLevel)
                    select p;

            var r = q.ToList();
```

この例での SupplierID および単価など、エンティティのプロパティを null 許容型に対して null 許容変数の数を比較しています。 パラメーター値が列の値と同じである場合、または両方のパラメーターと列の値が null の場合、このクエリに対して生成される SQL が求められます。 これは、データベース サーバーで null 値の処理方法は非表示にし、一貫性のある C を提供して\#別のデータベース ベンダー間でのエクスペリエンスは null です。 一方で、生成されたコードは多少複雑な処理し、場合にもを実行しない可能性があります比較の量で、クエリのステートメントは数が多いに増加します。

このような状況に対処する方法の 1 つは、データベースの null セマンティクスを使用することです。 この可能性のある動作が異なる c 注\#Entity Framework は、データベース エンジンは、null 値を処理する方法を公開するより単純な SQL を生成ここでは、以降のセマンティクスを null。 データベースの null セマンティクスはアクティブ化されたあたりコンテキスト、コンテキストの構成に対して 1 つの 1 つの構成行になります。

``` csharp
                context.Configuration.UseDatabaseNullSemantics = true;
```

小規模中規模からサイズのクエリしますが、表示されない比較的長いパフォーマンス向上のデータベースの null セマンティクスを使用する場合の違いは潜在的な null 比較の数が多いクエリをさらに顕著になります。

上記の例のクエリでは、パフォーマンスの違いは、制御された環境内で実行されている microbenchmark で 2% より小さいをでした。

### <a name="95------async"></a>9.5 非同期

Entity Framework 6 が導入された .NET 4.5 以降を実行しているときに、非同期操作をサポートします。 IO を持つアプリケーションが競合に関連するほとんどの場合、保存操作と非同期クエリを使用して、最もメリットが。 場合の IO の競合は、アプリケーションの低下がない、非同期は、最適な場合、同期的に実行しまたは最悪の場合の同期呼び出しと同じ量では、結果を返す、単にする非同期タスクの実行を遅らせるおよび使用余分な tim を追加自分のシナリオを完了する電子メール。

非同期のプログラミング作業に役立つかどうかも、非同期には、アプリケーションのパフォーマンスは向上を決定するアクセスについて[ http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx)します。 Entity Framework での非同期操作の使用に関する詳細については、次を参照してください。[非同期クエリと保存](~/ef6/fundamentals/async.md
)します。

### <a name="96------ngen"></a>9.6 NGEN

Entity Framework 6 には、.NET framework の既定のインストールにはなりません。 そのため、Entity Framework のアセンブリは NGEN が既定ですべての Entity Framework コードが他の任意の MSIL アセンブリとして同じ JIT'ing コストの対象であることを意味するの。 これにより、開発と運用環境でアプリケーションのコールド起動も中に、f5 キーを押してエクスペリエンスが低下する可能性があります。 JIT'ing の CPU とメモリのコストを削減するために、適切なイメージを Entity Framework ngen ことをお勧めします。 アセンブリを NGEN で Entity Framework 6 の起動時のパフォーマンスを向上させる方法の詳細については、次を参照してください。[アセンブリを NGen で起動時のパフォーマンスを向上させる](~/ef6/fundamentals/performance/ngen.md)します。

### <a name="97------code-first-versus-edmx"></a>9.7 は code First と EDMX

オブジェクト指向プログラミングと概念モデル (オブジェクト)、ストレージ スキーマ (データベース) との間のマッピングのメモリ内表現することでリレーショナル データベースの間のインピー ダンス ミスマッチ喰いについてエンティティ フレームワークの理由から、2 つです。 このメタデータには、エンティティ データ モデル、または EDM を短いと呼ばれます。 この EDM では、Entity Framework はラウンドト リップのデータをデータベースにメモリ内のオブジェクトから派生して、ビューと、バックアップを作成します。

概念モデル、ストレージ スキーマとマッピング、Entity Framework を使用する場合、EDMX ファイルを正式に指定し、モデルの読み込みステージは、EDM が正しいことを検証するのみが (たとえば、必ずマッピングが不足しないこと)、し、ビューを生成、ビューを検証して、このメタデータを使用できる状態があります。 のみがクエリを実行またはデータ ストアに新しいデータを保存します。

Code First アプローチは、感覚的に、高度な Entity Data Model ジェネレーターです。 Entity Framework で提供されているコード; から EDM を生成するためにはモデル、規則を適用して、Fluent API を使用してモデルの構成に関連するクラスを分析します。 EDM を作成すると、Entity Framework 基本的に同じように動作方法されて、プロジェクトに存在する EDMX ファイルがあったとします。 したがって、Code First のモデルの構築は、Entity Framework EDMX を持つと比較すると低速起動時間を変換する余分な複雑さを追加します。 コストは、サイズと複雑さが構築されるモデルの完全に依存します。

Code First と EDMX を使用するかは、Code First によって導入された柔軟性に最初に、モデルを構築するためのコストが増えることを知る必要があります。 場合、アプリケーションには、この初回使用時の負荷のコストが耐えられる、通常 Code First されます移動することをお勧めします。

## <a name="10-investigating-performance"></a>調査の 10 のパフォーマンス

### <a name="101-using-the-visual-studio-profiler"></a>10.1 Visual Studio Profiler を使用します。

Entity Framework のパフォーマンスの問題が発生した場合は、アプリケーションは、時間を費やしている場所を表示する Visual Studio に組み込まれているようにプロファイラーを使用できます。 これは、ツールの「ADO.NET Entity Framework - パート 1 のパフォーマンスを探索」ブログの投稿で円グラフを生成するために使用します ( \< http://blogs.msdn.com/b/adonet/archive/2008/02/04/exploring-the-performance-of-the-ado-net-entity-framework-part-1.aspx>) Entity Framework がコールドとウォームのクエリ中に、時間を費やすを表示します。

データとモデリングの Customer Advisory Team によって書き込まれた"プロファイルの Entity Framework が Visual Studio 2010 Profiler を使用して"ブログの投稿では、パフォーマンスの問題を調査するプロファイラーを使用する方法の実際の例を示します。  \<http://blogs.msdn.com/b/dmcat/archive/2010/04/30/profiling-entity-framework-using-the-visual-studio-2010-profiler.aspx>. この投稿は、windows アプリケーション用に記述されています。 Web アプリケーションをプロファイリングする必要がある場合、Windows Performance Recorder (WPR) と Windows パフォーマンス アナライザー (WPA) ツールが Visual Studio からの作業よりも優れた動作する可能性があります。 Windows アセスメントおよびデプロイメント キットに含まれており、Windows パフォーマンス ツールキットの一部である WPR および WPA ( [ http://www.microsoft.com/en-US/download/details.aspx?id=39982 ](https://www.microsoft.com/en-US/download/details.aspx?id=39982))。

### <a name="102-applicationdatabase-profiling"></a>10.2 データベース/アプリケーションのプロファイリング

Visual Studio に組み込まれているプロファイラーなどのツールは、アプリケーションが時間を費やす場所を伝えます。  プロファイラーの別の型が使用可能な実稼働またはニーズに応じて、実稼働前に、実行中のアプリケーションの動的分析を実行し、よくある落とし穴とデータベースへのアクセスのアンチ パターンの検索をします。

2 つの市販プロファイラーは、Entity Framework Profiler ( \< http://efprof.com>)と ORMProfiler ( \<http://ormprofiler.com>)します。

アプリケーションでは、Code First を使用して MVC アプリケーションは、StackExchange の MiniProfiler を使用することができます。 Scott Hanselman は、彼のブログでこのツールをについて説明します。 \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>します。

Julie Lerman の MSDN Magazine の記事「を参照してくださいアプリケーションのデータベース アクティビティのプロファイリングの詳細については[Entity Framework でのデータベース アクティビティのプロファイリング](https://msdn.microsoft.com/magazine/gg490349.aspx)します。

### <a name="103-database-logger"></a>10.3 データベース ロガー

Entity Framework 6 を使用している場合も、組み込みのログ記録機能を使用して検討してください。 コンテキストのデータベース プロパティは、単純な 1 行の構成を使用して、アクティビティ ログに記録するように指示することができます。

``` csharp
    using (var context = newQueryComparison.DbC.NorthwindEntities())
    {
        context.Database.Log = Console.WriteLine;
        var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
        q.ToList();
    }
```

この例では、データベース アクティビティをコンソールに記録されますが、ログのプロパティは、任意のアクションを呼び出します。 するように構成できます&lt;文字列&gt;を委任します。

有効にするせず、再コンパイルして、データベースのログ記録は、Entity Framework 6.1 を使用しているか、後で、これを行うアプリケーションの web.config または app.config ファイルでインターセプターを追加することで。

``` xml
  <interceptors>
    <interceptor type="System.Data.Entity.Infrastructure.Interception.DatabaseLogger, EntityFramework">
      <parameters>
        <parameter value="C:\Path\To\My\LogOutput.txt"/>
      </parameters>
    </interceptor>
  </interceptors>
```

詳細に移動してを再コンパイルせずにログ記録を追加する方法について\<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>します。

## <a name="11-appendix"></a>11 の付録

### <a name="111-a-test-environment"></a>11.1 A. テスト環境

この環境では、クライアント アプリケーションから別のコンピューター上のデータベースと 2 台のコンピューターのセットアップを使用します。 マシンは、ネットワーク待機時間が比較的低いが、1 台のコンピューター環境よりもより現実的なので、同じラックです。

#### <a name="1111-------app-server"></a>11.1.1 アプリ サーバー

##### <a name="11111------software-environment"></a>11.1.1.1 ソフトウェア環境

-   Entity Framework 4 のソフトウェアの環境
    -   OS 名: Windows Server 2008 R2 Enterprise SP1。
    -   Visual Studio 2010 – Ultimate。
    -   (いくつかの比較) の場合のみの visual Studio 2010 SP1
-   Entity Framework 5 および 6 ソフトウェア環境
    -   Windows 8.1 Enterprise の OS 名:
    -   Visual Studio 2013 – Ultimate。

##### <a name="11112------hardware-environment"></a>11.1.1.2 ハードウェア環境

-   デュアル プロセッサ: @ 2.27 GHz intel (r) Xeon(R) CPU L5520 W3530、2261 Mhz8 GHz、4 個のコア、84 の論理プロセッサ。
-   2412 GB RamRAM します。
-   136 GB SCSI250GB SATA 7200 rpm 3 GB/秒、ドライブが 4 つのパーティションに分割します。

#### <a name="1112-------db-server"></a>11.1.2 DB サーバー

##### <a name="11121------software-environment"></a>11.1.2.1 ソフトウェア環境

-   OS 名: Windows Server 2008 の R28.1 Enterprise SP1。
-   SQL Server 2008 R22012 します。

##### <a name="11122------hardware-environment"></a>11.1.2.2 ハードウェア環境

-   1 つのプロセッサ: intel (r) Xeon(R) CPU L5520 2.27 GHz、2261 MhzES-1620 0 @ 3.60 GHz、4 個のコア、8 の論理プロセッサ。
-   824 GB RamRAM します。
-   465 GB ATA500GB SATA 7200 rpm 6gb/s ドライブが 4 つのパーティションに分割します。

### <a name="112------b-query-performance-comparison-tests"></a>11.2 B. クエリのパフォーマンス比較テスト

Northwind モデルは、これらのテストの実行に使用されました。 これは、Entity Framework デザイナーを使用してデータベースから生成されました。 次に、次のコードは、クエリの実行オプションのパフォーマンスを比較に使用しました。

``` csharp
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.Entity.Infrastructure;
using System.Data.EntityClient;
using System.Data.Objects;
using System.Linq;

namespace QueryComparison
{
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
                );

        public IQueryable<Product> InvokeProductsForCategoryCQ(string categoryName)
        {
            return productsForCategoryCQ(this, categoryName);
        }
    }

    public class QueryTypePerfComparison
    {
        private static string entityConnectionStr = @"metadata=res://*/Northwind.csdl|res://*/Northwind.ssdl|res://*/Northwind.msl;provider=System.Data.SqlClient;provider connection string='data source=.;initial catalog=Northwind;integrated security=True;multipleactiveresultsets=True;App=EntityFramework'";

        public void LINQIncludingContextCreation()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTracking()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                context.Products.MergeOption = MergeOption.NoTracking;

                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void CompiledQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                var q = context.InvokeProductsForCategoryCQ("Beverages");
                q.ToList();
            }
        }

        public void ObjectQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
                products.ToList();
            }
        }

        public void EntityCommand()
        {
            using (EntityConnection eConn = new EntityConnection(entityConnectionStr))
            {
                eConn.Open();
                EntityCommand cmd = eConn.CreateCommand();
                cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

                using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
                {
                    List<Product> productsList = new List<Product>();
                    while (reader.Read())
                    {
                        DbDataRecord record = (DbDataRecord)reader.GetValue(0);

                        // 'materialize' the product by accessing each field and value. Because we are materializing products, we won't have any nested data readers or records.
                        int fieldCount = record.FieldCount;

                        // Treat all products as Product, even if they are the subtype DiscontinuedProduct.
                        Product product = new Product();  

                        product.ProductID = record.GetInt32(0);
                        product.ProductName = record.GetString(1);
                        product.SupplierID = record.GetInt32(2);
                        product.CategoryID = record.GetInt32(3);
                        product.QuantityPerUnit = record.GetString(4);
                        product.UnitPrice = record.GetDecimal(5);
                        product.UnitsInStock = record.GetInt16(6);
                        product.UnitsOnOrder = record.GetInt16(7);
                        product.ReorderLevel = record.GetInt16(8);
                        product.Discontinued = record.GetBoolean(9);

                        productsList.Add(product);
                    }
                }
            }
        }

        public void ExecuteStoreQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectResult<Product> beverages = context.ExecuteStoreQuery<Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Database.SqlQuery\<QueryComparison.DbC.Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbSet()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Products.SqlQuery(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void LINQIncludingContextCreationDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTrackingDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var q = context.Products.AsNoTracking().Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }
    }
}
```

### <a name="113-c-navision-model"></a>11.3 C. Navision モデル

Navision データベースは、Microsoft Dynamics – ナビゲーションのデモに使用される大規模なデータベース 生成された概念モデルには、1005 エンティティ セットおよび 4227 のアソシエーション セットが含まれています。 テストで使用されるモデルは「フラット」– 継承が追加されていませんが。

#### <a name="1131-queries-used-for-navision-tests"></a>11.3.1 Navision テストに使用されるクエリ

Navision モデルで使用するクエリの一覧には、Entity SQL クエリの 3 つのカテゴリが含まれています。

##### <a name="11311-lookup"></a>11.3.1.1 参照

集計を持たないシンプルなルックアップ クエリ

-   カウント: 16232
-   例:

``` xml
  <Query complexity="Lookup">
    <CommandText>Select value distinct top(4) e.Idle_Time From NavisionFKContext.Session as e</CommandText>
  </Query>
```

##### <a name="11312-singleaggregating"></a>11.3.1.2 SingleAggregating

通常の BI クエリで複数の集計がない小計 (1 つのクエリ)

-   カウント: 2313
-   例:

``` xml
  <Query complexity="SingleAggregating">
    <CommandText>NavisionFK.MDF_SessionLogin_Time_Max()</CommandText>
  </Query>
```

場所 MDF\_SessionLogin\_時間\_Max() がモデルで定義されています。

``` xml
  <Function Name="MDF_SessionLogin_Time_Max" ReturnType="Collection(DateTime)">
    <DefiningExpression>SELECT VALUE Edm.Min(E.Login_Time) FROM NavisionFKContext.Session as E</DefiningExpression>
  </Function>
```

##### <a name="11313-aggregatingsubtotals"></a>11.3.1.3 AggregatingSubtotals

集計と集計 (すべての和集合) を使用して BI クエリ

-   カウント: 178
-   例:

``` xml
  <Query complexity="AggregatingSubtotals">
    <CommandText>
using NavisionFK;
function AmountConsumed(entities Collection([CRONUS_International_Ltd__Zone])) as
(
    Edm.Sum(select value N.Block_Movement FROM entities as E, E.CRONUS_International_Ltd__Bin as N)
)
function AmountConsumed(P1 Edm.Int32) as
(
    AmountConsumed(select value e from NavisionFKContext.CRONUS_International_Ltd__Zone as e where e.Zone_Ranking = P1)
)
----------------------------------------------------------------------------------------------------------------------
(
    select top(10) Zone_Ranking, Cross_Dock_Bin_Zone, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking, E.Cross_Dock_Bin_Zone
)
union all
(
    select top(10) Zone_Ranking, Cast(null as Edm.Byte) as P2, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking
)
union all
{
    Row(Cast(null as Edm.Int32) as P1, Cast(null as Edm.Byte) as P2, AmountConsumed(select value E
                                                                         from NavisionFKContext.CRONUS_International_Ltd__Zone as E
                                                                         where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed))
}</CommandText>
    <Parameters>
      <Parameter Name="MinAmountConsumed" DbType="Int32" Value="10000" />
    </Parameters>
  </Query>
```
